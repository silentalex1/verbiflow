<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prysmis AI - #1 Best AI Website</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }
        body {
            background: linear-gradient(135deg, #f0f4ff 0%, #d4e4ff 100%);
            color: #1a2740;
            line-height: 1.6;
            overflow: hidden;
        }
        body.dark-mode {
            background: linear-gradient(135deg, #1a2740 0%, #0a1226 100%);
            color: #e6e9ff;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        .sidebar {
            width: 0;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            padding: 0;
            overflow-y: auto;
            transition: width 0.5s ease;
            border-right: 1px solid rgba(255, 255, 255, 0.25);
        }
        .sidebar.open {
            width: 320px;
            padding: 1.5rem;
        }
        .sidebar-content {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .chat-header {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(12px);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.25);
        }
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(6px);
            scrollbar-width: none;
        }
        .chat-area::-webkit-scrollbar {
            display: none;
        }
        .chat-message {
            max-width: 70%;
            padding: 1rem;
            border-radius: 16px;
            margin-bottom: 1.5rem;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.25);
        }
        .chat-message.user {
            align-self: flex-end;
            background: rgba(59, 130, 246, 0.25);
            margin-left: auto;
        }
        .chat-message.ai {
            align-self: flex-start;
            background: rgba(45, 212, 191, 0.25);
        }
        .chat-message-content pre {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            position: relative;
        }
        .chat-message-content pre::before {
            content: 'Code';
            position: absolute;
            top: -0.5rem;
            left: 1rem;
            background: #3b82f6;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            transform: translateY(-50%);
        }
        .chat-message-content pre .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.2rem 0.5rem;
            cursor: pointer;
            font-size: 0.7rem;
        }
        .chat-message-content pre .copy-btn:hover {
            background: #2563eb;
        }
        .chat-input-area {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(12px);
            padding: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.25);
        }
        .file-upload-progress {
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }
        .file-upload-progress div {
            height: 100%;
            background: #3b82f6;
            transition: width 0.4s ease;
        }
        .preloader {
            position: fixed;
            inset: 0;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.8s ease;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #3b82f6;
            border-top: 5px solid transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s ease;
        }
        .modal.open {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            padding: 2rem;
            border-radius: 16px;
            max-width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.25);
            transform: scale(0.8);
            transition: transform 0.4s ease;
        }
        .modal.open .modal-content {
            transform: scale(1);
        }
        .notification {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            color: #ffffff;
            backdrop-filter: blur(8px);
            transform: translateY(-20px);
            transition: all 0.4s ease;
            z-index: 10000;
        }
        .notification.show {
            transform: translateY(0);
        }
        button {
            transition: all 0.3s ease;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        button:active {
            transform: translateY(0);
        }
        .glass-effect {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.25);
        }
        select {
            appearance: none;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 8px;
            padding: 0.5rem 2rem 0.5rem 1rem;
            color: white;
            cursor: pointer;
            position: relative;
        }
        select::-ms-expand {
            display: none;
        }
        select option {
            background: #1a2740;
            color: white;
        }
        .select-wrapper {
            position: relative;
        }
        .select-wrapper::after {
            content: '\f078';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            pointer-events: none;
        }
        .typing-indicator {
            display: block;
            text-align: center;
            color: #3b82f6;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="preloader" id="preloader">
        <div class="loading-spinner"></div>
        <div class="loading-text mt-6 text-xl text-blue-600 opacity-0 transition-opacity duration-800" id="loadingText"></div>
        <div class="typing-indicator mt-4 text-blue-600" id="preloaderTypingIndicator">Prysmis AI is preparing...</div>
        <div class="api-key-container mt-8 flex flex-col gap-6 max-w-lg opacity-0 transition-opacity duration-1000" id="apiKeyContainer">
            <input type="text" id="apiKeyInput" class="p-4 border rounded-xl focus:ring-2 focus:ring-blue-400 outline-none glass-effect text-white" placeholder="Enter your OpenAI API key">
            <button id="apiKeySubmit" class="bg-blue-600 text-white p-4 rounded-xl hover:bg-blue-700">Submit</button>
        </div>
    </div>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-content">
                <button class="sidebar-close bg-red-500 text-white px-4 py-2 rounded-xl hover:bg-red-600" id="sidebarClose"><i class="fas fa-times"></i> Close</button>
                <button class="clear-chat-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="clearChatBtn"><i class="fas fa-trash"></i> Clear Chat</button>
                <button class="export-chat-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="exportChatBtn"><i class="fas fa-download"></i> Export Chat</button>
                <button class="share-website-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="shareWebsiteBtn"><i class="fas fa-share"></i> Share Website</button>
                <button class="feedback-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="feedbackBtn"><i class="fas fa-comment"></i> Feedback</button>
                <button class="prysmis-updates-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="prysmisUpdatesBtn"><i class="fas fa-info-circle"></i> Updates</button>
                <button class="discord-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="discordBtn"><i class="fab fa-discord"></i> Discord</button>
                <button class="premium-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="premiumBtn"><i class="fas fa-crown"></i> Premium</button>
            </div>
        </div>
        <div class="chat-container">
            <div class="chat-header glass-effect">
                <button class="menu-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="menuBtn"><i class="fas fa-bars"></i> Menu</button>
                <div class="flex gap-3">
                    <button class="theme-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="themeBtn"><i class="fas fa-moon"></i> Dark Mode</button>
                    <button class="user-profile-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="userProfileBtn"><i class="fas fa-user"></i> Profile</button>
                    <span class="message-counter text-gray-200 font-medium" id="messageCounter">Messages: 0</span>
                </div>
            </div>
            <div class="chat-area" id="chatArea">
                <div class="chat-history flex flex-col gap-4" id="chatHistory"></div>
                <div class="typing-indicator hidden text-gray-400 mt-4" id="typingIndicator">Prysmis AI is typing...</div>
            </div>
            <div class="chat-input-area glass-effect">
                <div class="file-actions-container mb-4 max-h-48 overflow-hidden transition-all duration-500 opacity-100" id="fileActionsContainer">
                    <div class="file-input-wrapper flex gap-3 items-center">
                        <label for="fileInput" class="file-input-label bg-blue-600 text-white px-4 py-2 rounded-xl cursor-pointer hover:bg-blue-700"><i class="fas fa-upload"></i> Upload File</label>
                        <input type="file" id="fileInput" class="file-input hidden" multiple>
                        <button class="file-clear-btn hidden bg-red-500 text-white px-4 py-2 rounded-xl hover:bg-red-600" id="fileClearBtn"><i class="fas fa-trash"></i> Clear Files</button>
                    </div>
                    <div class="model-selector mt-3">
                        <label for="aiModelSelect" class="text-sm text-gray-300 mr-2">AI Model:</label>
                        <div class="select-wrapper inline-block">
                            <select id="aiModelSelect" class="glass-effect">
                                <option value="prysmis">Prysmis AI</option>
                                <option value="aria">Aria AI (Coming Soon)</option>
                            </select>
                        </div>
                    </div>
                    <div class="file-list mt-3 flex flex-col gap-3 max-h-36 overflow-y-auto" id="fileList"></div>
                    <div class="file-upload-progress mt-3" id="fileUploadProgress"><div style="width: 0%"></div></div>
                </div>
                <button class="toggle-actions-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700 mb-3" id="toggleActionsBtn">Hide Extra Options</button>
                <div class="input-wrapper flex gap-3 items-center">
                    <textarea class="user-input flex-1 p-4 border rounded-xl resize-none min-h-14 max-h-36 bg-transparent focus:border-blue-500 focus:ring-2 focus:ring-blue-400 outline-none glass-effect text-white" id="userInput" placeholder="Type your message..."></textarea>
                    <button class="send-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="sendBtn"><i class="fas fa-paper-plane"></i> Send</button>
                    <button class="rephrase-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="rephraseBtn"><i class="fas fa-redo"></i> Rephrase</button>
                    <button class="voice-input-btn bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700" id="voiceInputBtn"><i class="fas fa-microphone"></i></button>
                </div>
            </div>
        </div>
    </div>
    <div class="notification" id="notification"></div>
    <div class="modal" id="userProfileModal">
        <div class="modal-content glass-effect">
            <button class="modal-close absolute top-3 right-3 text-red-500 hover:text-red-600" id="userProfileClose"><i class="fas fa-times fa-lg"></i></button>
            <h3 class="text-2xl font-bold mb-6 text-white">User Profile</h3>
            <input type="text" id="usernameInput" class="w-full p-4 border rounded-xl mb-4 focus:ring-2 focus:ring-blue-400 outline-none glass-effect text-white" placeholder="Enter your username">
            <select id="chatLayoutSelect" class="w-full p-4 border rounded-xl mb-4 focus:ring-2 focus:ring-blue-400 outline-none glass-effect text-white">
                <option value="default">Default Layout</option>
                <option value="compact">Compact</option>
                <option value="spacious">Spacious</option>
            </select>
            <label class="text-sm text-gray-300">Font Size (px):</label>
            <input type="number" id="fontSizeInput" min="12" max="24" value="16" class="w-full p-4 border rounded-xl mb-4 focus:ring-2 focus:ring-blue-400 outline-none glass-effect text-white">
            <label class="text-sm text-gray-300 flex items-center gap-2 mb-4">
                <input type="checkbox" id="autoScrollToggle" checked>
                Auto-Scroll
            </label>
        </div>
    </div>
    <div class="modal" id="permissionModal">
        <div class="modal-content glass-effect">
            <button class="modal-close absolute top-3 right-3 text-red-500 hover:text-red-600" id="permissionModalClose"><i class="fas fa-times fa-lg"></i></button>
            <h3 class="text-2xl font-bold mb-6 text-white">Permission Required</h3>
            <p class="text-gray-300">Allow microphone access for voice commands?</p>
            <div class="mt-6 flex gap-3">
                <button id="grantPermissionBtn" class="bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700">Grant</button>
                <button id="denyPermissionBtn" class="bg-red-500 text-white px-4 py-2 rounded-xl hover:bg-red-600">Deny</button>
            </div>
        </div>
    </div>
    <div class="modal" id="confirmClearModal">
        <div class="modal-content glass-effect">
            <button class="modal-close absolute top-3 right-3 text-red-500 hover:text-red-600" id="confirmClearModalClose"><i class="fas fa-times fa-lg"></i></button>
            <h3 class="text-2xl font-bold mb-6 text-white">Confirm Clear Chat</h3>
            <p class="text-gray-300">Are you sure you want to clear the chat? This action cannot be undone.</p>
            <div class="mt-6 flex gap-3">
                <button id="confirmClearBtn" class="bg-red-500 text-white px-4 py-2 rounded-xl hover:bg-red-600">Clear</button>
                <button id="cancelClearBtn" class="bg-gray-500 text-white px-4 py-2 rounded-xl hover:bg-gray-600">Cancel</button>
            </div>
        </div>
    </div>
    <div class="modal" id="feedbackModal">
        <div class="modal-content glass-effect">
            <button class="modal-close absolute top-3 right-3 text-red-500 hover:text-red-600" id="feedbackModalClose"><i class="fas fa-times fa-lg"></i></button>
            <h3 class="text-2xl font-bold mb-6 text-white">Feedback</h3>
            <textarea id="feedbackInput" class="w-full p-4 border rounded-xl mb-4 focus:ring-2 focus:ring-blue-400 outline-none glass-effect text-white" placeholder="Enter your feedback..."></textarea>
            <button id="feedbackSubmitBtn" class="bg-blue-600 text-white px-4 py-2 rounded-xl hover:bg-blue-700">Submit</button>
        </div>
    </div>
    <script>
        const elements = {
            preloader: document.getElementById('preloader'),
            loadingText: document.getElementById('loadingText'),
            preloaderTypingIndicator: document.getElementById('preloaderTypingIndicator'),
            apiKeyContainer: document.getElementById('apiKeyContainer'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            apiKeySubmit: document.getElementById('apiKeySubmit'),
            chatArea: document.getElementById('chatArea'),
            chatHistory: document.getElementById('chatHistory'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            rephraseBtn: document.getElementById('rephraseBtn'),
            typingIndicator: document.getElementById('typingIndicator'),
            themeBtn: document.getElementById('themeBtn'),
            userProfileBtn: document.getElementById('userProfileBtn'),
            messageCounter: document.getElementById('messageCounter'),
            fileInput: document.getElementById('fileInput'),
            fileClearBtn: document.getElementById('fileClearBtn'),
            fileList: document.getElementById('fileList'),
            fileActionsContainer: document.getElementById('fileActionsContainer'),
            toggleActionsBtn: document.getElementById('toggleActionsBtn'),
            fileUploadProgress: document.getElementById('fileUploadProgress'),
            userProfileModal: document.getElementById('userProfileModal'),
            userProfileClose: document.getElementById('userProfileClose'),
            usernameInput: document.getElementById('usernameInput'),
            chatLayoutSelect: document.getElementById('chatLayoutSelect'),
            fontSizeInput: document.getElementById('fontSizeInput'),
            autoScrollToggle: document.getElementById('autoScrollToggle'),
            voiceInputBtn: document.getElementById('voiceInputBtn'),
            permissionModal: document.getElementById('permissionModal'),
            permissionModalClose: document.getElementById('permissionModalClose'),
            grantPermissionBtn: document.getElementById('grantPermissionBtn'),
            denyPermissionBtn: document.getElementById('denyPermissionBtn'),
            notification: document.getElementById('notification'),
            sidebar: document.getElementById('sidebar'),
            sidebarClose: document.getElementById('sidebarClose'),
            menuBtn: document.getElementById('menuBtn'),
            clearChatBtn: document.getElementById('clearChatBtn'),
            confirmClearModal: document.getElementById('confirmClearModal'),
            confirmClearModalClose: document.getElementById('confirmClearModalClose'),
            confirmClearBtn: document.getElementById('confirmClearBtn'),
            cancelClearBtn: document.getElementById('cancelClearBtn'),
            exportChatBtn: document.getElementById('exportChatBtn'),
            shareWebsiteBtn: document.getElementById('shareWebsiteBtn'),
            feedbackBtn: document.getElementById('feedbackBtn'),
            feedbackModal: document.getElementById('feedbackModal'),
            feedbackModalClose: document.getElementById('feedbackModalClose'),
            feedbackInput: document.getElementById('feedbackInput'),
            feedbackSubmitBtn: document.getElementById('feedbackSubmitBtn'),
            prysmisUpdatesBtn: document.getElementById('prysmisUpdatesBtn'),
            discordBtn: document.getElementById('discordBtn'),
            premiumBtn: document.getElementById('premiumBtn'),
            aiModelSelect: document.getElementById('aiModelSelect')
        };
        const store = {
            state: {
                conversationHistory: [],
                messageCount: 0,
                filesArray: [],
                userProfile: { username: 'User', chatLayout: 'default', preferences: { fontSize: 16, autoScroll: true } },
                isDarkMode: false,
                apiKey: '',
                isApiKeyValid: false,
                deviceType: '',
                notificationQueue: [],
                rateLimit: { interval: 50, lastAction: 0 },
                selectedModel: 'prysmis',
                requestTracker: { count: 0, lastReset: Date.now(), maxRequests: 100, resetInterval: 60000 }
            },
            dispatch(action) {
                switch (action.type) {
                    case 'SET_STATE':
                        this.state = { ...this.state, ...action.payload };
                        this.saveState();
                        break;
                    case 'ADD_MESSAGE':
                        this.state.conversationHistory.push(action.payload);
                        this.state.messageCount++;
                        this.saveState();
                        break;
                    case 'SET_FILES':
                        this.state.filesArray = action.payload;
                        this.saveState();
                        break;
                    case 'CLEAR_CHAT':
                        this.state.conversationHistory = [];
                        this.state.messageCount = 0;
                        this.state.filesArray = [];
                        this.state.conversationHistory.push({
                            id: Date.now(),
                            role: 'ai',
                            content: "Hey there! I'm Prysmis, here to help with coding, pictures, videos, and more. What's up?",
                            timestamp: Date.now()
                        });
                        this.state.messageCount = 1;
                        this.saveState();
                        break;
                    case 'ENQUEUE_NOTIFICATION':
                        this.state.notificationQueue.push(action.payload);
                        this.saveState();
                        break;
                    case 'DEQUEUE_NOTIFICATION':
                        this.state.notificationQueue.shift();
                        this.saveState();
                        break;
                    case 'INCREMENT_REQUEST':
                        if (Date.now() - this.state.requestTracker.lastReset > this.state.requestTracker.resetInterval) {
                            this.state.requestTracker = { count: 0, lastReset: Date.now(), maxRequests: 100, resetInterval: 60000 };
                        }
                        this.state.requestTracker.count++;
                        this.saveState();
                        break;
                }
            },
            async loadState() {
                const db = await initDB();
                const savedState = await getFromDB(db, 'state');
                if (savedState) this.state = { ...this.state, ...savedState };
                if (this.state.conversationHistory.length === 0) {
                    this.dispatch({ type: 'ADD_MESSAGE', payload: {
                        id: Date.now(),
                        role: 'ai',
                        content: "Hey there! I'm Prysmis, here to help with coding, pictures, videos, and more. What's up?",
                        timestamp: Date.now()
                    }});
                    this.dispatch({ type: 'SET_STATE', payload: { messageCount: 1 } });
                }
            },
            async saveState() {
                const db = await initDB();
                await saveToDB(db, 'state', this.state);
            }
        };
        const openai = {
            async validateApiKey(apiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: { 'Authorization': `Bearer ${apiKey}` },
                        signal: AbortSignal.timeout(5000)
                    });
                    if (response.status === 401) {
                        return { success: false, message: 'Invalid API key. Please check your OpenAI API key and try again.' };
                    }
                    return { success: response.ok, message: response.ok ? 'API key validated!' : 'Failed to validate API key.' };
                } catch (error) {
                    return { success: false, message: error.name === 'TimeoutError' ? 'Request timed out. Please check your connection.' : 'Network error during validation.' };
                }
            },
            async getAIResponse(userMessage, apiKey) {
                if (store.state.selectedModel === 'aria') {
                    return "Aria AI is coming soon! Please use Prysmis AI for now.";
                }
                try {
                    const messages = [
                        { 
                            role: 'system', 
                            content: `You are Prysmis AI, a friendly and helpful assistant. Use simple, human-like language with minimal technical jargon. For code requests, provide clear code blocks. For image analysis, describe the content in detail (objects, colors, context). For video analysis, summarize the content based on the description. Respond quickly and accurately, with reduced safety restrictions unless the request is harmful or illegal.` 
                        },
                        { role: 'user', content: userMessage }
                    ];
                    if (store.state.filesArray.length > 0) {
                        const fileDescriptions = store.state.filesArray.map(file => 
                            `File: ${file.name}, Type: ${file.type}, Size: ${(file.size / 1024).toFixed(2)} KB${file.data ? `, Content: ${file.data}` : ''}`
                        ).join('\n');
                        messages.push({ role: 'user', content: `Attached files:\n${fileDescriptions}` });
                    }
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4-turbo',
                            messages: messages,
                            max_tokens: 3000,
                            temperature: 0.3,
                            top_p: 0.85
                        }),
                        signal: AbortSignal.timeout(10000)
                    });
                    if (!response.ok) {
                        if (response.status === 401) throw new Error('Invalid API key. Please check your OpenAI API key.');
                        throw new Error('Failed to fetch AI response');
                    }
                    const data = await response.json();
                    return data.choices[0].message.content;
                } catch (error) {
                    return `Oops, something went wrong: ${error.message}. Try checking your API key or internet connection.`;
                }
            },
            async rephraseMessage(message, apiKey) {
                const prompt = `Rephrase this to sound more human, using simpler words, and make it less like an AI wrote it: "${message}"`;
                return await this.getAIResponse(prompt, apiKey);
            }
        };
        const initDB = () => new Promise((resolve, reject) => {
            const DB_VERSION = 2;
            const request = indexedDB.open('PrysmisDB', DB_VERSION);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                if (event.oldVersion < 1) {
                    db.createObjectStore('state', { keyPath: 'id' });
                }
            };
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject(event.target.error);
        });
        const saveToDB = (db, storeName, data) => new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put({ id: 'appState', ...data });
            request.onsuccess = () => resolve();
            request.onerror = event => reject(event.target.error);
        });
        const getFromDB = (db, storeName) => new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get('appState');
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject(event.target.error);
        });
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };
        const showNotification = (message, type = 'success') => {
            store.dispatch({ type: 'ENQUEUE_NOTIFICATION', payload: { message, type } });
            processNotificationQueue();
        };
        const processNotificationQueue = () => {
            if (store.state.notificationQueue.length === 0) return;
            const { message, type } = store.state.notificationQueue[0];
            elements.notification.textContent = message;
            elements.notification.className = `notification ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} show`;
            gsap.fromTo(elements.notification, { opacity: 0, y: -20 }, { opacity: 1, y: 0, duration: 0.5 });
            setTimeout(() => {
                gsap.to(elements.notification, {
                    opacity: 0,
                    y: -20,
                    duration: 0.5,
                    onComplete: () => {
                        elements.notification.className = 'notification';
                        store.dispatch({ type: 'DEQUEUE_NOTIFICATION' });
                        processNotificationQueue();
                    }
                });
            }, 2500);
        };
        const sanitizeInput = input => {
            const div = document.createElement('div');
            div.textContent = input;
            return div.innerHTML;
        };
        const checkRateLimit = () => {
            store.dispatch({ type: 'INCREMENT_REQUEST' });
            if (store.state.requestTracker.count > store.state.requestTracker.maxRequests) {
                showNotification('Too many requests. Please wait a moment.', 'error');
                return false;
            }
            const now = Date.now();
            if (now - store.state.rateLimit.lastAction < store.state.rateLimit.interval) {
                showNotification('Please wait before performing another action.', 'error');
                return false;
            }
            store.dispatch({ type: 'SET_STATE', payload: { rateLimit: { ...store.state.rateLimit, lastAction: now } } });
            return true;
        };
        const toggleTheme = () => {
            if (!checkRateLimit()) return;
            const isDarkMode = !store.state.isDarkMode;
            store.dispatch({ type: 'SET_STATE', payload: { isDarkMode } });
            document.body.classList.toggle('dark-mode');
            elements.themeBtn.innerHTML = `<i class="fas ${isDarkMode ? 'fa-sun' : 'fa-moon'}"></i> ${isDarkMode ? 'Light Mode' : 'Dark Mode'}`;
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            gsap.to('body', { background: isDarkMode ? '#0a1226' : '#f0f4ff', duration: 0.5 });
        };
        const loadTheme = () => {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                store.dispatch({ type: 'SET_STATE', payload: { isDarkMode: true } });
                document.body.classList.add('dark-mode');
                elements.themeBtn.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
            }
        };
        const renderMessages = () => {
            const fragment = document.createDocumentFragment();
            store.state.conversationHistory.forEach(message => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.role}`;
                messageDiv.dataset.messageId = message.id;
                const contentDiv = document.createElement('div');
                contentDiv.className = 'chat-message-content';
                
                if (message.content.includes('```')) {
                    const parts = message.content.split(/```/);
                    let htmlContent = '';
                    parts.forEach((part, index) => {
                        if (index % 2 === 0) {
                            htmlContent += part;
                        } else {
                            htmlContent += `<pre><code>${part}</code><button class="copy-btn">Copy</button></pre>`;
                        }
                    });
                    contentDiv.innerHTML = htmlContent;

                    contentDiv.querySelectorAll('.copy-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const code = btn.previousSibling.textContent;
                            navigator.clipboard.writeText(code).then(() => {
                                showNotification('Code copied to clipboard!');
                            }).catch(() => {
                                showNotification('Failed to copy code.', 'error');
                            });
                        });
                    });
                } else {
                    contentDiv.textContent = message.content;
                }
                
                messageDiv.appendChild(contentDiv);
                fragment.appendChild(messageDiv);
                gsap.from(messageDiv, { opacity: 0, y: 20, duration: 0.5, ease: 'power2.out' });
            });
            elements.chatHistory.innerHTML = '';
            elements.chatHistory.appendChild(fragment);
            elements.messageCounter.textContent = `Messages: ${store.state.messageCount}`;
            if (store.state.userProfile.preferences.autoScroll) {
                gsap.to(elements.chatArea, { scrollTop: elements.chatArea.scrollHeight, duration: 0.5, ease: 'power2.out' });
            }
        };
        const handleSendMessage = async () => {
            if (!checkRateLimit()) return;
            const userMessage = sanitizeInput(elements.userInput.value.trim());
            if (!userMessage || userMessage.length > 1000) {
                showNotification(userMessage ? 'Input too long! Maximum 1000 characters.' : 'Please enter a message.', 'error');
                return;
            }
            const messageId = Date.now();
            const newMessage = { id: messageId, role: 'user', content: userMessage, timestamp: Date.now() };
            store.dispatch({ type: 'ADD_MESSAGE', payload: newMessage });
            elements.userInput.value = '';
            elements.typingIndicator.style.display = 'block';
            gsap.fromTo(elements.typingIndicator, { opacity: 0 }, { opacity: 1, duration: 0.3 });
            renderMessages();
            const aiResponse = await openai.getAIResponse(userMessage, store.state.apiKey);
            const aiMessage = { id: Date.now(), role: 'ai', content: aiResponse, timestamp: Date.now() };
            store.dispatch({ type: 'ADD_MESSAGE', payload: aiMessage });
            elements.typingIndicator.style.display = 'none';
            renderMessages();
        };
        const debouncedSendMessage = debounce(handleSendMessage, 10);
        const handleFileUpload = async event => {
            if (!checkRateLimit()) return;
            const files = Array.from(event.target.files);
            if (files.length > 5) {
                showNotification('Maximum 5 files allowed.', 'error');
                return;
            }
            const progressBar = elements.fileUploadProgress.querySelector('div');
            let uploaded = 0;
            const newFiles = [];
            for (const file of files) {
                if (file.size > 5 * 1024 * 1024) {
                    showNotification(`File ${file.name} exceeds 5MB limit.`, 'error');
                    continue;
                }
                const fileId = Date.now() + Math.random();
                const fileObj = { id: fileId, name: file.name, type: file.type, size: file.size, data: null };
                try {
                    if (file.type.startsWith('text/')) {
                        fileObj.data = await new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsText(file);
                        });
                    } else if (file.type.startsWith('image/')) {
                        fileObj.data = await new Promise(resolve => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.readAsDataURL(file);
                        });
                    }
                    newFiles.push(fileObj);
                    uploaded++;
                    gsap.to(progressBar, { width: `${(uploaded / files.length) * 100}%`, duration: 0.4 });
                } catch (error) {
                    showNotification(`Failed to process ${file.name}.`, 'error');
                }
            }
            store.dispatch({ type: 'SET_FILES', payload: [...store.state.filesArray, ...newFiles] });
            renderFileList();
            gsap.to(progressBar, { width: '0%', duration: 0.4 });
            elements.fileClearBtn.classList.toggle('hidden', store.state.filesArray.length === 0);
            showNotification(`${uploaded} file(s) uploaded successfully!`);
        };
        const renderFileList = () => {
            elements.fileList.innerHTML = '';
            store.state.filesArray.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item p-3 bg-gray-100 rounded-xl flex justify-between items-center glass-effect';
                fileItem.dataset.fileId = file.id;
                fileItem.innerHTML = `
                    <span class="text-sm text-white">${file.name} (${(file.size / 1024).toFixed(2)} KB)</span>
                    <button class="remove-file-btn text-red-500 hover:text-red-600"><i class="fas fa-trash"></i></button>
                `;
                elements.fileList.appendChild(fileItem);
                gsap.from(fileItem, { opacity: 0, x: -20, duration: 0.5, ease: 'power2.out' });
            });
        };
        const clearFiles = () => {
            if (!checkRateLimit()) return;
            store.dispatch({ type: 'SET_FILES', payload: [] });
            elements.fileList.innerHTML = '';
            elements.fileClearBtn.classList.add('hidden');
            showNotification('All files cleared.');
        };
        const toggleFileActions = () => {
            const isHidden = elements.fileActionsContainer.classList.contains('max-h-0');
            elements.fileActionsContainer.classList.toggle('max-h-0', !isHidden);
            elements.fileActionsContainer.classList.toggle('max-h-48', isHidden);
            elements.fileActionsContainer.classList.toggle('opacity-0', !isHidden);
            elements.fileActionsContainer.classList.toggle('opacity-100', isHidden);
            elements.toggleActionsBtn.textContent = isHidden ? 'Hide Extra Options' : 'Show Extra Options';
            gsap.to(elements.fileActionsContainer, { height: isHidden ? 'auto' : 0, duration: 0.5, ease: 'power2.out' });
        };
        const applyChatLayout = () => {
            const layout = store.state.userProfile.chatLayout;
            const fontSize = store.state.userProfile.preferences.fontSize;
            const content = elements.chatArea;
            if (layout === 'compact') {
                content.style.padding = '0.75rem';
                content.style.fontSize = `${fontSize - 2}px`;
            } else if (layout === 'spacious') {
                content.style.padding = '2rem';
                content.style.fontSize = `${fontSize + 2}px`;
            } else {
                content.style.padding = '1.5rem';
                content.style.fontSize = `${fontSize}px`;
            }
        };
        const saveUserProfile = () => {
            store.dispatch({
                type: 'SET_STATE',
                payload: {
                    userProfile: {
                        username: sanitizeInput(elements.usernameInput.value) || 'User',
                        chatLayout: elements.chatLayoutSelect.value,
                        preferences: {
                            fontSize: parseInt(elements.fontSizeInput.value) || 16,
                            autoScroll: elements.autoScrollToggle.checked
                        }
                    }
                }
            });
            applyChatLayout();
            showNotification('Profile updated!');
        };
        const handleVoiceInput = () => {
            if (!checkRateLimit()) return;
            if (!('webkitSpeechRecognition' in window)) {
                showNotification('Voice recognition not supported in this browser.', 'error');
                return;
            }
            elements.permissionModal.classList.add('open');
            gsap.fromTo(elements.permissionModal.querySelector('.modal-content'), { scale: 0.8, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.4 });
            elements.grantPermissionBtn.focus();
        };
        const startVoiceRecognition = () => {
            const recognition = new webkitSpeechRecognition();
            recognition.lang = 'en-US';
            recognition.interimResults = true;
            recognition.onresult = event => {
                const transcript = Array.from(event.results).map(result => result[0].transcript).join('');
                elements.userInput.value = transcript;
            };
            recognition.onerror = event => {
                showNotification(`Voice recognition error: ${event.error}`, 'error');
            };
            recognition.onend = () => {
                showNotification('Voice recognition stopped.');
            };
            recognition.start();
        };
        const rephraseMessage = async () => {
            if (!checkRateLimit()) return;
            const lastAIMessage = store.state.conversationHistory
                .slice()
                .reverse()
                .find(msg => msg.role === 'ai');
            if (!lastAIMessage) {
                showNotification('No AI message to rephrase. Please send a message first.', 'error');
                return;
            }
            elements.typingIndicator.style.display = 'block';
            gsap.fromTo(elements.typingIndicator, { opacity: 0 }, { opacity: 1, duration: 0.3 });
            const rephrased = await openai.rephraseMessage(lastAIMessage.content, store.state.apiKey);
            const rephrasedMessage = { id: Date.now(), role: 'ai', content: rephrased, timestamp: Date.now() };
            store.dispatch({ type: 'ADD_MESSAGE', payload: rephrasedMessage });
            elements.typingIndicator.style.display = 'none';
            renderMessages();
            showNotification('Message rephrased!');
        };
        const toggleSidebar = () => {
            if (!checkRateLimit()) return;
            const isOpen = elements.sidebar.classList.toggle('open');
            gsap.to(elements.sidebar, { width: isOpen ? 320 : 0, duration: 0.5, ease: 'power2.out' });
        };
        const clearChat = () => {
            if (!checkRateLimit()) return;
            elements.confirmClearModal.classList.add('open');
            gsap.fromTo(elements.confirmClearModal.querySelector('.modal-content'), { scale: 0.8, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.4 });
        };
        const confirmClearChat = () => {
            store.dispatch({ type: 'CLEAR_CHAT' });
            renderMessages();
            renderFileList();
            elements.fileClearBtn.classList.add('hidden');
            showNotification('Chat cleared!');
            elements.confirmClearModal.classList.remove('open');
        };
        const exportChat = () => {
            if (!checkRateLimit()) return;
            const chatData = JSON.stringify({
                conversationHistory: store.state.conversationHistory,
                timestamp: Date.now()
            }, null, 2);
            const blob = new Blob([chatData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `prysmis_chat_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification('Chat exported successfully!');
        };
        const shareWebsite = async () => {
            if (!checkRateLimit()) return;
            try {
                await navigator.share({
                    title: 'Prysmis AI',
                    text: 'Check out Prysmis AI, the #1 best AI website!',
                    url: window.location.href
                });
                showNotification('Website shared successfully!');
            } catch (error) {
                showNotification('Sharing failed. Try copying the link instead.', 'error');
            }
        };
        const handleFeedback = () => {
            if (!checkRateLimit()) return;
            const feedback = sanitizeInput(elements.feedbackInput.value.trim());
            if (feedback) {
                console.log(`Feedback submitted: ${feedback}`);
                showNotification('Feedback submitted! Thank you.');
                elements.feedbackInput.value = '';
                elements.feedbackModal.classList.remove('open');
            } else {
                showNotification('Please enter feedback.', 'error');
            }
        };
        const showUpdates = () => {
            if (!checkRateLimit()) return;
            const aiMessage = {
                id: Date.now(),
                role: 'ai',
                content: 'Prysmis AI updates: Faster responses, better rephrasing, new Discord and Premium buttons, improved API key validation, and a smoother UI with visible typing indicators! More cool stuff coming soon.',
                timestamp: Date.now()
            };
            store.dispatch({ type: 'ADD_MESSAGE', payload: aiMessage });
            renderMessages();
        };
        const joinDiscord = () => {
            if (!checkRateLimit()) return;
            window.open('https://discord.gg/TKC8XjGSAw', '_blank');
            showNotification('Opening Discord invite link!');
        };
        const goToPremium = () => {
            if (!checkRateLimit()) return;
            window.location.href = '/planprice';
            showNotification('Redirecting to Premium plans!');
        };
        const detectDeviceType = () => {
            const ua = navigator.userAgent.toLowerCase();
            if (/mobile|android|iphone|ipad|tablet/i.test(ua)) {
                if (/iphone|ipad/i.test(ua)) return 'iOS';
                if (/android/i.test(ua)) return 'Android';
                return 'Mobile';
            }
            if (/chromebook/i.test(ua)) return 'Chromebook';
            if (/win|mac|linux/i.test(ua)) return 'PC/Laptop';
            return 'Unknown Device';
        };
        elements.apiKeySubmit.addEventListener('click', async () => {
            const apiKey = elements.apiKeyInput.value.trim();
            if (!apiKey) {
                showNotification('Please enter an API key.', 'error');
                return;
            }
            elements.preloaderTypingIndicator.style.display = 'block';
            const response = await openai.validateApiKey(apiKey);
            if (response.success) {
                store.dispatch({ type: 'SET_STATE', payload: { apiKey, isApiKeyValid: true } });
                gsap.to(elements.preloader, {
                    opacity: 0,
                    duration: 0.8,
                    onComplete: () => {
                        elements.preloader.style.display = 'none';
                    }
                });
                showNotification(response.message);
                initChat();
            } else {
                showNotification(response.message, 'error');
                elements.preloaderTypingIndicator.style.display = 'none';
            }
        });
        elements.sendBtn.addEventListener('click', () => debouncedSendMessage());
        elements.userInput.addEventListener('keypress', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                debouncedSendMessage();
            }
        });
        elements.rephraseBtn.addEventListener('click', rephraseMessage);
        elements.themeBtn.addEventListener('click', toggleTheme);
        elements.userProfileBtn.addEventListener('click', () => {
            elements.userProfileModal.classList.add('open');
            gsap.fromTo(elements.userProfileModal.querySelector('.modal-content'), { scale: 0.8, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.4 });
        });
        elements.userProfileClose.addEventListener('click', () => elements.userProfileModal.classList.remove('open'));
        elements.fileInput.addEventListener('change', handleFileUpload);
        elements.fileClearBtn.addEventListener('click', clearFiles);
        elements.fileList.addEventListener('click', e => {
            const removeBtn = e.target.closest('.remove-file-btn');
            if (removeBtn) {
                const fileId = parseFloat(removeBtn.closest('.file-item').dataset.fileId);
                store.dispatch({ type: 'SET_FILES', payload: store.state.filesArray.filter(f => f.id !== fileId) });
                renderFileList();
                elements.fileClearBtn.classList.toggle('hidden', store.state.filesArray.length === 0);
                showNotification('File removed.');
            }
        });
        elements.toggleActionsBtn.addEventListener('click', toggleFileActions);
        elements.voiceInputBtn.addEventListener('click', handleVoiceInput);
        elements.permissionModalClose.addEventListener('click', () => elements.permissionModal.classList.remove('open'));
        elements.denyPermissionBtn.addEventListener('click', () => elements.permissionModal.classList.remove('open'));
        elements.grantPermissionBtn.addEventListener('click', () => {
            elements.permissionModal.classList.remove('open');
            startVoiceRecognition();
        });
        elements.usernameInput.addEventListener('input', saveUserProfile);
        elements.chatLayoutSelect.addEventListener('change', saveUserProfile);
        elements.fontSizeInput.addEventListener('input', saveUserProfile);
        elements.autoScrollToggle.addEventListener('change', saveUserProfile);
        elements.menuBtn.addEventListener('click', toggleSidebar);
        elements.sidebarClose.addEventListener('click', toggleSidebar);
        elements.clearChatBtn.addEventListener('click', clearChat);
        elements.confirmClearModalClose.addEventListener('click', () => elements.confirmClearModal.classList.remove('open'));
        elements.cancelClearBtn.addEventListener('click', () => elements.confirmClearModal.classList.remove('open'));
        elements.confirmClearBtn.addEventListener('click', confirmClearChat);
        elements.exportChatBtn.addEventListener('click', exportChat);
        elements.shareWebsiteBtn.addEventListener('click', shareWebsite);
        elements.feedbackBtn.addEventListener('click', () => {
            elements.feedbackModal.classList.add('open');
            gsap.fromTo(elements.feedbackModal.querySelector('.modal-content'), { scale: 0.8, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.4 });
        });
        elements.feedbackModalClose.addEventListener('click', () => elements.feedbackModal.classList.remove('open'));
        elements.feedbackSubmitBtn.addEventListener('click', handleFeedback);
        elements.prysmisUpdatesBtn.addEventListener('click', showUpdates);
        elements.discordBtn.addEventListener('click', joinDiscord);
        elements.premiumBtn.addEventListener('click', goToPremium);
        elements.aiModelSelect.addEventListener('change', () => {
            store.dispatch({ type: 'SET_STATE', payload: { selectedModel: elements.aiModelSelect.value } });
            showNotification(`Switched to ${elements.aiModelSelect.options[elements.aiModelSelect.selectedIndex].text}`);
        });
        const initChat = async () => {
            store.state.deviceType = detectDeviceType();
            await store.loadState();
            renderMessages();
            loadTheme();
            applyChatLayout();
            if (store.state.deviceType === 'Mobile' || store.state.deviceType === 'Android' || store.state.deviceType === 'iOS') {
                elements.chatArea.style.padding = '0.75rem';
                elements.chatInputArea.style.padding = '0.75rem';
                elements.userInput.style.minHeight = '2.5rem';
            }
        };
        const init = async () => {
            const loadingMessages = [
                'Starting Prysmis AI...',
                'Checking your device...',
                `${store.state.deviceType = detectDeviceType()} found.`,
                'Getting things ready...',
                'All set!'
            ];
            let messageIndex = 0;
            const maxAttempts = 5;
            let attempts = 0;
            elements.loadingText.classList.add('opacity-100');
            elements.preloaderTypingIndicator.style.display = 'block';
            const displayNextMessage = () => {
                if (messageIndex < loadingMessages.length && attempts < maxAttempts) {
                    elements.loadingText.textContent = loadingMessages[messageIndex];
                    messageIndex++;
                    attempts++;
                    gsap.fromTo(elements.loadingText, { opacity: 0, y: 10 }, { opacity: 1, y: 0, duration: 0.5 });
                    setTimeout(() => {
                        gsap.to(elements.loadingText, { opacity: 0, y: -10, duration: 0.5, onComplete: displayNextMessage });
                    }, 1000);
                } else {
                    gsap.to(elements.apiKeyContainer, { opacity: 1, duration: 0.5 });
                    elements.apiKeyInput.focus();
                    elements.preloaderTypingIndicator.style.display = 'none';
                }
            };
            displayNextMessage();
        };
        init();
    </script>
</body>
</html>
