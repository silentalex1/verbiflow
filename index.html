<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VerbiFlow - Ultra-Fast AI Companion</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            color: #1e293b;
            line-height: 1.6;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        body.dark-mode {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            color: #e2e8f0;
        }
        body.custom-theme {
            background: var(--custom-bg, #f8fafc) !important;
        }
        body.custom-theme .chat-message.ai {
            background: var(--custom-ai-bg, #e0f2fe) !important;
        }
        body.custom-theme .chat-message.user {
            background: var(--custom-user-bg, #ecfdf5) !important;
        }
        body.custom-theme .sidebar, body.custom-theme .modal {
            background: var(--custom-secondary, #ffffff) !important;
        }
        body.custom-theme .btn, body.custom-theme .modal button {
            background: var(--custom-primary, #3b82f6) !important;
            color: var(--custom-text, #ffffff) !important;
        }
        body.custom-theme .chat-area, body.custom-theme .chat-input-area {
            background: var(--custom-gradient, #e2e8f0) !important;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
            position: relative;
            overflow: hidden;
        }
        .sidebar {
            width: 280px;
            background: #ffffff;
            padding: 20px;
            position: fixed;
            top: 0;
            left: -280px;
            height: 100%;
            transition: left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
            box-shadow: 3px 0 15px rgba(0, 0, 0, 0.05);
        }
        .sidebar.open {
            left: 0;
        }
        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .sidebar h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #3b82f6;
        }
        .sidebar-close {
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #ef4444;
            transition: color 0.3s ease;
        }
        .sidebar-close:hover {
            color: #dc2626;
        }
        .sidebar-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #94a3b8 #e2e8f0;
        }
        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }
        .sidebar-content::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 3px;
        }
        .sidebar-content::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
        .sidebar-content select, .sidebar-content button {
            padding: 10px 12px;
            font-size: 0.95rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            width: 100%;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .sidebar-content select {
            background: #f8fafc;
            color: #1e293b;
        }
        .sidebar-content button {
            background: #3b82f6;
            color: white;
            border: none;
            font-weight: 500;
        }
        .sidebar-content button:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            margin-left: 0;
            transition: margin-left 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .chat-header {
            background: #ffffff;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        .menu-btn, .theme-btn, .user-profile-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }
        .menu-btn:hover, .theme-btn:hover, .user-profile-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8fafc;
            position: relative;
            scrollbar-width: thin;
            scrollbar-color: #94a3b8 #f8fafc;
        }
        .chat-area::-webkit-scrollbar {
            width: 6px;
        }
        .chat-area::-webkit-scrollbar-track {
            background: #f8fafc;
            border-radius: 3px;
        }
        .chat-area::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
        .chat-history {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .chat-message {
            display: flex;
            flex-direction: column;
            max-width: 80%;
            padding: 10px;
            border-radius: 10px;
            opacity: 0;
            transform: translateY(15px) scale(0.98);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .chat-message.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        .chat-message.user {
            align-self: flex-end;
            background: #ecfdf5;
        }
        .chat-message.ai {
            align-self: flex-start;
            background: #e0f2fe;
        }
        .chat-message.threaded-message {
            margin-left: 40px;
            border-left: 2px solid #3b82f6;
            padding-left: 10px;
        }
        .chat-message.pinned {
            border: 2px solid #fef08a;
            background: #fefce8;
        }
        .chat-message-content {
            padding: 12px 16px;
            font-size: 15px;
            line-height: 1.5;
            word-wrap: break-word;
            border-radius: 8px;
        }
        .chat-message-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: #64748b;
            margin-top: 6px;
        }
        .chat-message-actions {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .chat-message-actions button {
            background: none;
            border: none;
            cursor: pointer;
            color: #3b82f6;
            font-size: 0.75rem;
            transition: color 0.3s ease;
        }
        .chat-message-actions button:hover {
            color: #2563eb;
        }
        .reaction-emoji {
            font-size: 0.9rem;
            margin-right: 4px;
        }
        .typing-indicator {
            display: none;
            font-size: 0.85rem;
            color: #64748b;
            margin: 12px 0;
        }
        .typing-indicator::after {
            content: '...';
            animation: dots 1.2s infinite;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
        }
        .response-spinner {
            display: none;
            width: 18px;
            height: 18px;
            border: 2px solid #3b82f6;
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 0.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            margin: 12px 0;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .chat-input-area {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background: #ffffff;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        }
        .file-actions-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
            transition: max-height 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
            max-height: 200px;
            opacity: 1;
            overflow: hidden;
        }
        .file-actions-container.collapsed {
            max-height: 0;
            opacity: 0;
        }
        .file-input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .file-input {
            display: none;
        }
        .file-input-label, .file-clear-btn {
            padding: 8px 12px;
            background: #3b82f6;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        .file-clear-btn {
            display: none;
            background: #ef4444;
        }
        .file-input-label:hover, .file-clear-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .file-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-height: 100px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #94a3b8 #f8fafc;
        }
        .file-list::-webkit-scrollbar {
            width: 6px;
        }
        .file-list::-webkit-scrollbar-track {
            background: #f8fafc;
            border-radius: 3px;
        }
        .file-list::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 3px;
        }
        .file-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: #f1f5f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .file-item:hover {
            background: #e2e8f0;
        }
        .file-item-name {
            flex: 1;
            font-size: 0.85rem;
        }
        .file-item-details {
            font-size: 0.75rem;
            color: #64748b;
        }
        .toggle-actions-btn {
            align-self: flex-end;
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }
        .toggle-actions-btn:hover {
            background: #2563eb;
        }
        .toggle-actions-btn.collapsed::after {
            content: 'Show File Actions';
        }
        .toggle-actions-btn:not(.collapsed)::after {
            content: 'Hide File Actions';
        }
        .input-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .user-input {
            flex: 1;
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            resize: none;
            font-size: 0.95rem;
            min-height: 40px;
            max-height: 120px;
            overflow-y: auto;
            background: #f8fafc;
            transition: all 0.3s ease;
        }
        .user-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
            background: #ffffff;
        }
        .send-btn, .rephrase-btn, .stop-generating-btn {
            padding: 8px 14px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }
        .send-btn:hover, .rephrase-btn:hover, .stop-generating-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);
        }
        .stop-generating-btn {
            display: none;
            background: #ef4444;
        }
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .modal.open {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: #ffffff;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
            transform: scale(0.95);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .modal.open .modal-content {
            transform: scale(1);
        }
        .modal-content h3 {
            margin-bottom: 15px;
            font-size: 1.25rem;
            font-weight: 600;
        }
        .modal-content input, .modal-content textarea, .modal-content select {
            width: 100%;
            padding: 10px;
            margin-bottom: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }
        .modal-content input:focus, .modal-content textarea:focus, .modal-content select:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        .modal-content textarea {
            resize: vertical;
            min-height: 100px;
        }
        .modal-content button {
            padding: 8px 14px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 8px;
            transition: all 0.3s ease;
        }
        .modal-content button:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }
        .modal-content button.cancel {
            background: #ef4444;
        }
        .modal-content button.cancel:hover {
            background: #dc2626;
        }
        .modal-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #ef4444;
            transition: color 0.3s ease;
        }
        .modal-close:hover {
            color: #dc2626;
        }
        .file-preview-modal .modal-content {
            max-width: 700px;
        }
        .file-preview-content {
            display: flex;
            justify-content: center;
            align-items: center;
            max-height: 500px;
            overflow: auto;
        }
        .file-preview-content img, .file-preview-content video {
            max-width: 100%;
            max-height: 100%;
        }
        .zoom-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            gap: 8px;
        }
        .zoom-controls button {
            padding: 8px;
            font-size: 1.2rem;
            background: #3b82f6;
            color: white;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        .zoom-controls button:hover {
            background: #2563eb;
        }
        .search-results {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .search-result-item {
            padding: 10px;
            background: #f1f5f9;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .search-result-item:hover {
            background: #e2e8f0;
        }
        .highlight {
            background: #fef08a;
            font-weight: 500;
        }
        .theme-customizer {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }
        .theme-customizer div {
            flex: 1 1 45%;
            display: flex;
            flex-direction: column;
        }
        .theme-customizer label {
            font-size: 0.85rem;
            margin-bottom: 4px;
            color: #64748b;
        }
        .theme-customizer input[type="color"] {
            padding: 0;
            height: 40px;
            cursor: pointer;
            border: none;
        }
        .theme-preview {
            width: 100%;
            height: 50px;
            margin-top: 12px;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            background: #22c55e;
            color: white;
            border-radius: 6px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1001;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        .notification.error {
            background: #ef4444;
        }
        .back-to-top-btn {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .back-to-top-btn.visible {
            opacity: 1;
            visibility: visible;
        }
        .message-counter {
            font-size: 0.85rem;
            color: #64748b;
            margin-left: 12px;
        }
        .preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            transition: opacity 0.6s ease;
        }
        .preloader.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-text {
            font-size: 1.1rem;
            color: #3b82f6;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        .loading-text.visible {
            opacity: 1;
        }
        .api-key-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 400px;
            opacity: 0;
            transition: opacity 0.6s ease;
        }
        .api-key-container.visible {
            opacity: 1;
        }
        .api-key-container input {
            padding: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }
        .api-key-container input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        body.mobile .sidebar {
            width: 100%;
            left: -100%;
        }
        body.mobile .sidebar.open {
            left: 0;
        }
        body.mobile .chat-message {
            max-width: 90%;
        }
        body.mobile .modal-content {
            width: 95%;
        }
        body.chromebook .chat-area {
            font-size: 0.9rem;
        }
        .typing-animation::after {
            content: '|';
            animation: blink 0.8s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="preloader" id="preloader">
        <div class="loading-text" id="loadingText">Loading...</div>
        <div class="api-key-container" id="apiKeyContainer">
            <input type="text" id="apiKeyInput" placeholder="Enter your OpenAI API key">
            <button id="apiKeySubmit">Submit</button>
        </div>
    </div>
    <div class="container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>VerbiFlow</h2>
                <button class="sidebar-close" id="sidebarClose"><i class="fas fa-times"></i></button>
            </div>
            <div class="sidebar-content">
                <select id="aiModelDropdown">
                    <option value="default">Default Model</option>
                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                    <option value="gpt-4">GPT-4</option>
                </select>
                <select id="languageDropdown">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                </select>
                <select id="schoolHelpDropdown">
                    <option value="">Select Task</option>
                    <option value="math">Math Help</option>
                    <option value="essay">Essay Writing</option>
                    <option value="coding">Coding Help</option>
                </select>
                <button id="clearChatBtn"><i class="fas fa-trash"></i> Clear Chat</button>
                <button id="copyCodeBtn"><i class="fas fa-code"></i> Copy Last Code</button>
                <button id="exportChatBtn"><i class="fas fa-download"></i> Export Chat</button>
                <button id="discordBtn"><i class="fab fa-discord"></i> Join Discord</button>
                <button id="verbiflowUpdatesBtn"><i class="fas fa-bell"></i> VerbiFlow Updates</button>
                <button id="premiumPriceBtn"><i class="fas fa-crown"></i> Premium Pricing</button>
                <button id="shareChatBtn"><i class="fas fa-share-alt"></i> Share Chat</button>
                <button id="shareWebsiteBtn"><i class="fas fa-globe"></i> Share Website</button>
                <button id="feedbackBtn"><i class="fas fa-comment-dots"></i> Feedback</button>
                <button id="voiceSearchBtn"><i class="fas fa-microphone"></i> Voice Search</button>
                <button id="searchBtn"><i class="fas fa-search"></i> Search Messages</button>
                <button id="generateMediaBtn"><i class="fas fa-image"></i> Generate Media</button>
            </div>
        </div>
        <div class="main-content">
            <div class="chat-header">
                <button class="menu-btn" id="menuBtn"><i class="fas fa-bars"></i> Menu</button>
                <div>
                    <button class="theme-btn" id="themeBtn"><i class="fas fa-moon"></i> Dark Mode</button>
                    <button class="user-profile-btn" id="userProfileBtn"><i class="fas fa-user"></i> Profile</button>
                    <span class="message-counter" id="messageCounter">Messages: 0</span>
                </div>
            </div>
            <div class="chat-area" id="chatArea">
                <div class="chat-history" id="chatHistory"></div>
                <div class="typing-indicator" id="typingIndicator">VerbiFlow is typing</div>
                <div class="response-spinner" id="responseSpinner"></div>
            </div>
            <div class="chat-input-area">
                <div class="file-actions-container" id="fileActionsContainer">
                    <div class="file-input-wrapper">
                        <label for="fileInput" class="file-input-label"><i class="fas fa-upload"></i> Upload File</label>
                        <input type="file" id="fileInput" class="file-input" multiple>
                        <button class="file-clear-btn" id="fileClearBtn"><i class="fas fa-trash"></i> Clear Files</button>
                    </div>
                    <div class="file-list" id="fileList"></div>
                </div>
                <button class="toggle-actions-btn" id="toggleActionsBtn"></button>
                <div class="input-wrapper">
                    <textarea class="user-input" id="userInput" placeholder="Type your message..."></textarea>
                    <button class="send-btn" id="sendBtn"><i class="fas fa-paper-plane"></i> Send</button>
                    <button class="rephrase-btn" id="rephraseBtn"><i class="fas fa-redo"></i> Rephrase</button>
                    <button class="stop-generating-btn" id="stopGeneratingBtn"><i class="fas fa-stop"></i> Stop</button>
                </div>
            </div>
        </div>
    </div>
    <div class="notification" id="notification"></div>
    <button class="back-to-top-btn" id="backToTopBtn"><i class="fas fa-arrow-up"></i></button>
    <div class="modal" id="confirmClearModal">
        <div class="modal-content">
            <button class="modal-close" id="confirmClearModalClose"><i class="fas fa-times"></i></button>
            <h3>Confirm Clear Chat</h3>
            <p>Are you sure you want to clear the chat? This action cannot be undone.</p>
            <button id="confirmClearBtn">Yes, Clear</button>
            <button class="cancel" id="cancelClearBtn">Cancel</button>
        </div>
    </div>
    <div class="modal file-preview-modal" id="filePreviewModal">
        <div class="modal-content">
            <button class="modal-close" id="filePreviewClose"><i class="fas fa-times"></i></button>
            <div class="file-preview-content" id="filePreviewContent"></div>
            <div class="zoom-controls" id="zoomControls">
                <button id="zoomIn"><i class="fas fa-search-plus"></i></button>
                <button id="zoomOut"><i class="fas fa-search-minus"></i></button>
            </div>
        </div>
    </div>
    <div class="modal" id="userProfileModal">
        <div class="modal-content">
            <button class="modal-close" id="userProfileClose"><i class="fas fa-times"></i></button>
            <h3>User Profile</h3>
            <input type="text" id="usernameInput" placeholder="Enter your username">
            <select id="chatLayoutSelect">
                <option value="default">Default Layout</option>
                <option value="compact">Compact</option>
                <option value="spacious">Spacious</option>
            </select>
            <label>Font Size (px):</label>
            <input type="number" id="fontSizeInput" min="12" max="24" value="16">
            <label>Auto-Scroll:</label>
            <input type="checkbox" id="autoScrollToggle" checked>
            <h4>Theme Customizer</h4>
            <div class="theme-customizer">
                <div>
                    <label>Primary Color</label>
                    <input type="color" id="primaryColor" value="#3b82f6">
                </div>
                <div>
                    <label>Secondary Color</label>
                    <input type="color" id="secondaryColor" value="#ffffff">
                </div>
                <div>
                    <label>Text Color</label>
                    <input type="color" id="textColor" value="#ffffff">
                </div>
                <div>
                    <label>Background</label>
                    <input type="color" id="bgColor" value="#f8fafc">
                </div>
                <div>
                    <label>AI Message BG</label>
                    <input type="color" id="aiBgColor" value="#e0f2fe">
                </div>
                <div>
                    <label>User Message BG</label>
                    <input type="color" id="userBgColor" value="#ecfdf5">
                </div>
                <div>
                    <label>Gradient Color</label>
                    <input type="color" id="gradientColor" value="#e2e8f0">
                </div>
            </div>
            <div class="theme-preview" id="themePreview"></div>
        </div>
    </div>
    <div class="modal" id="permissionModal">
        <div class="modal-content">
            <button class="modal-close" id="permissionModalClose"><i class="fas fa-times"></i></button>
            <h3>Permission Required</h3>
            <p>Allow microphone access for voice search?</p>
            <button id="grantPermissionBtn">Grant</button>
            <button class="cancel" id="denyPermissionBtn">Deny</button>
        </div>
    </div>
    <div class="modal" id="feedbackModal">
        <div class="modal-content">
            <button class="modal-close" id="feedbackModalClose"><i class="fas fa-times"></i></button>
            <h3>Feedback</h3>
            <textarea id="feedbackInput" placeholder="Enter your feedback..."></textarea>
            <button id="feedbackSubmitBtn">Submit</button>
        </div>
    </div>
    <div class="modal" id="searchModal">
        <div class="modal-content">
            <button class="modal-close" id="searchModalClose"><i class="fas fa-times"></i></button>
            <h3>Search Messages</h3>
            <input type="text" id="searchModalInput" placeholder="Search messages...">
            <div class="search-results" id="searchResults"></div>
        </div>
    </div>
    <div class="modal" id="editMessageModal">
        <div class="modal-content">
            <button class="modal-close" id="editMessageClose"><i class="fas fa-times"></i></button>
            <h3>Edit Message</h3>
            <textarea id="editMessageInput"></textarea>
            <button id="saveEditBtn">Save</button>
        </div>
    </div>
    <script>
        const WEBSITE_URL = 'https://verbiflow.site';
        const DISCORD_INVITE = 'https://discord.gg/verbiflow';
        const FEEDBACK_EMAIL = 'feedback@verbiflow.site';
        const elements = {
            preloader: document.getElementById('preloader'),
            loadingText: document.getElementById('loadingText'),
            apiKeyContainer: document.getElementById('apiKeyContainer'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            apiKeySubmit: document.getElementById('apiKeySubmit'),
            sidebar: document.getElementById('sidebar'),
            sidebarClose: document.getElementById('sidebarClose'),
            menuBtn: document.getElementById('menuBtn'),
            chatArea: document.getElementById('chatArea'),
            chatHistory: document.getElementById('chatHistory'),
            userInput: document.getElementById('userInput'),
            sendBtn: document.getElementById('sendBtn'),
            rephraseBtn: document.getElementById('rephraseBtn'),
            stopGeneratingBtn: document.getElementById('stopGeneratingBtn'),
            typingIndicator: document.getElementById('typingIndicator'),
            responseSpinner: document.getElementById('responseSpinner'),
            themeBtn: document.getElementById('themeBtn'),
            userProfileBtn: document.getElementById('userProfileBtn'),
            messageCounter: document.getElementById('messageCounter'),
            fileInput: document.getElementById('fileInput'),
            fileClearBtn: document.getElementById('fileClearBtn'),
            fileList: document.getElementById('fileList'),
            fileActionsContainer: document.getElementById('fileActionsContainer'),
            toggleActionsBtn: document.getElementById('toggleActionsBtn'),
            filePreviewModal: document.getElementById('filePreviewModal'),
            filePreviewContent: document.getElementById('filePreviewContent'),
            filePreviewClose: document.getElementById('filePreviewClose'),
            zoomControls: document.getElementById('zoomControls'),
            zoomIn: document.getElementById('zoomIn'),
            zoomOut: document.getElementById('zoomOut'),
            clearChatBtn: document.getElementById('clearChatBtn'),
            confirmClearModal: document.getElementById('confirmClearModal'),
            confirmClearModalClose: document.getElementById('confirmClearModalClose'),
            confirmClearBtn: document.getElementById('confirmClearBtn'),
            cancelClearBtn: document.getElementById('cancelClearBtn'),
            copyCodeBtn: document.getElementById('copyCodeBtn'),
            exportChatBtn: document.getElementById('exportChatBtn'),
            discordBtn: document.getElementById('discordBtn'),
            verbiflowUpdatesBtn: document.getElementById('verbiflowUpdatesBtn'),
            premiumPriceBtn: document.getElementById('premiumPriceBtn'),
            shareChatBtn: document.getElementById('shareChatBtn'),
            shareWebsiteBtn: document.getElementById('shareWebsiteBtn'),
            feedbackBtn: document.getElementById('feedbackBtn'),
            feedbackModal: document.getElementById('feedbackModal'),
            feedbackModalClose: document.getElementById('feedbackModalClose'),
            feedbackInput: document.getElementById('feedbackInput'),
            feedbackSubmitBtn: document.getElementById('feedbackSubmitBtn'),
            voiceSearchBtn: document.getElementById('voiceSearchBtn'),
            permissionModal: document.getElementById('permissionModal'),
            permissionModalClose: document.getElementById('permissionModalClose'),
            grantPermissionBtn: document.getElementById('grantPermissionBtn'),
            denyPermissionBtn: document.getElementById('denyPermissionBtn'),
            searchBtn: document.getElementById('searchBtn'),
            searchModal: document.getElementById('searchModal'),
            searchModalClose: document.getElementById('searchModalClose'),
            searchModalInput: document.getElementById('searchModalInput'),
            searchResults: document.getElementById('searchResults'),
            generateMediaBtn: document.getElementById('generateMediaBtn'),
            userProfileModal: document.getElementById('userProfileModal'),
            userProfileClose: document.getElementById('userProfileClose'),
            usernameInput: document.getElementById('usernameInput'),
            chatLayoutSelect: document.getElementById('chatLayoutSelect'),
            fontSizeInput: document.getElementById('fontSizeInput'),
            autoScrollToggle: document.getElementById('autoScrollToggle'),
            primaryColor: document.getElementById('primaryColor'),
            secondaryColor: document.getElementById('secondaryColor'),
            textColor: document.getElementById('textColor'),
            bgColor: document.getElementById('bgColor'),
            aiBgColor: document.getElementById('aiBgColor'),
            userBgColor: document.getElementById('userBgColor'),
            gradientColor: document.getElementById('gradientColor'),
            themePreview: document.getElementById('themePreview'),
            schoolHelpDropdown: document.getElementById('schoolHelpDropdown'),
            aiModelDropdown: document.getElementById('aiModelDropdown'),
            languageDropdown: document.getElementById('languageDropdown'),
            editMessageModal: document.getElementById('editMessageModal'),
            editMessageClose: document.getElementById('editMessageClose'),
            editMessageInput: document.getElementById('editMessageInput'),
            saveEditBtn: document.getElementById('saveEditBtn'),
            notification: document.getElementById('notification'),
            backToTopBtn: document.getElementById('backToTopBtn')
        };
        const store = {
            state: {
                conversationHistory: [],
                messageCount: 0,
                filesArray: [],
                pinnedMessages: new Set(),
                threads: {},
                messageDrafts: { userInput: '' },
                userProfile: { username: 'User', chatLayout: 'default', preferences: { fontSize: 16, autoScroll: true } },
                zoomLevel: 1,
                isDarkMode: false,
                selectedModel: 'default',
                selectedLanguage: 'en',
                selectedTask: '',
                latestCodeBlocks: [],
                userStats: { messagesSent: 0, reactionsAdded: 0, threadsCreated: 0 },
                searches: [],
                notificationQueue: [],
                rateLimit: { interval: 400, lastAction: 0 },
                currentPage: 1,
                messagesPerPage: 50,
                typingSpeed: 25,
                isGenerating: false,
                apiKey: '',
                isApiKeyValid: false,
                deviceType: '',
                conversationContext: [],
                aiMemory: {}
            },
            dispatch(action) {
                switch (action.type) {
                    case 'SET_STATE':
                        this.state = { ...this.state, ...action.payload };
                        this.saveState();
                        break;
                    case 'ADD_MESSAGE':
                        this.state.conversationHistory.push(action.payload);
                        this.state.messageCount++;
                        this.state.userStats.messagesSent++;
                        this.state.conversationContext.push({ role: action.payload.role, content: action.payload.content });
                        if (this.state.conversationContext.length > 10) this.state.conversationContext.shift();
                        this.updateAIMemory(action.payload);
                        this.saveState();
                        break;
                    case 'ADD_THREAD_MESSAGE':
                        if (!this.state.threads[action.payload.threadId]) {
                            this.state.threads[action.payload.threadId] = [];
                            this.state.userStats.threadsCreated++;
                        }
                        this.state.threads[action.payload.threadId].push(action.payload);
                        this.state.messageCount++;
                        this.state.userStats.messagesSent++;
                        this.state.conversationContext.push({ role: action.payload.role, content: action.payload.content });
                        if (this.state.conversationContext.length > 10) this.state.conversationContext.shift();
                        this.updateAIMemory(action.payload);
                        this.saveState();
                        break;
                    case 'UPDATE_MESSAGE':
                        const msgIndex = this.state.conversationHistory.findIndex(m => m.id === action.payload.id);
                        if (msgIndex !== -1) {
                            this.state.conversationHistory[msgIndex] = action.payload;
                        } else {
                            Object.values(this.state.threads).forEach(thread => {
                                const threadMsgIndex = thread.findIndex(m => m.id === action.payload.id);
                                if (threadMsgIndex !== -1) thread[threadMsgIndex] = action.payload;
                            });
                        }
                        this.saveState();
                        break;
                    case 'PIN_MESSAGE':
                        this.state.pinnedMessages.add(action.payload);
                        this.saveState();
                        break;
                    case 'UNPIN_MESSAGE':
                        this.state.pinnedMessages.delete(action.payload);
                        this.saveState();
                        break;
                    case 'SET_FILES':
                        this.state.filesArray = action.payload;
                        this.saveState();
                        break;
                    case 'SET_DRAFT':
                        this.state.messageDrafts = { ...this.state.messageDrafts, ...action.payload };
                        this.saveState();
                        break;
                    case 'CLEAR_DRAFT':
                        this.state.messageDrafts[action.payload] = '';
                        this.saveState();
                        break;
                    case 'ADD_REACTION':
                        this.state.userStats.reactionsAdded++;
                        this.saveState();
                        break;
                    case 'ADD_SEARCH':
                        this.state.searches.push(action.payload);
                        this.saveState();
                        break;
                    case 'SET_PAGE':
                        this.state.currentPage = action.payload;
                        this.saveState();
                        break;
                    case 'ENQUEUE_NOTIFICATION':
                        this.state.notificationQueue.push(action.payload);
                        this.saveState();
                        break;
                    case 'DEQUEUE_NOTIFICATION':
                        this.state.notificationQueue.shift();
                        this.saveState();
                        break;
                    case 'UPDATE_AI_MEMORY':
                        this.updateAIMemory(action.payload);
                        this.saveState();
                        break;
                }
            },
            updateAIMemory(message) {
                if (message.role === 'user') {
                    const keywords = message.content.toLowerCase().split(/\W+/).filter(word => word.length > 3);
                    keywords.forEach(keyword => {
                        if (!this.state.aiMemory[keyword]) this.state.aiMemory[keyword] = [];
                        this.state.aiMemory[keyword].push({ id: message.id, content: message.content, timestamp: message.timestamp });
                        if (this.state.aiMemory[keyword].length > 5) this.state.aiMemory[keyword].shift();
                    });
                }
            },
            async loadState() {
                try {
                    const db = await initDB();
                    const savedState = await getFromDB(db, 'state');
                    if (savedState) {
                        this.state = { ...this.state, ...savedState, pinnedMessages: new Set(savedState.pinnedMessages || []) };
                    }
                    const welcomeMessage = { id: Date.now(), role: 'ai', content: "Hey there, I’m VerbiFlow—your ultra-fast AI companion for creativity, coding, analytics, and more! What’s on your mind?", reactions: [], threadId: null, timestamp: Date.now() };
                    this.dispatch({ type: 'ADD_MESSAGE', payload: welcomeMessage });
                    this.dispatch({ type: 'SET_STATE', payload: { messageCount: 1 } });
                } catch (error) {
                    console.error('Failed to load state:', error);
                }
            },
            async saveState() {
                try {
                    const db = await initDB();
                    const stateToSave = { ...this.state, pinnedMessages: Array.from(this.state.pinnedMessages) };
                    await saveToDB(db, 'state', stateToSave);
                } catch (error) {
                    console.error('Failed to save state:', error);
                }
            }
        };
        const mockBackend = {
            async validateApiKey(apiKey) {
                try {
                    const response = await fetch('https://api.openai.com/v1/models', {
                        headers: { 'Authorization': `Bearer ${apiKey}` }
                    });
                    if (response.ok) {
                        return { success: true, message: 'API key validated successfully!' };
                    }
                    const errorData = await response.json();
                    return { success: false, message: errorData.error?.message || 'Invalid API key.' };
                } catch (error) {
                    return { success: false, message: 'Network error. Please check your connection.' };
                }
            },
            async getAIResponse(userMessage, apiKey, model, language, task, context, memory) {
                try {
                    const taskPrompt = task ? `Task: ${task}. ` : '';
                    const langPrompt = language !== 'en' ? ` Respond in ${language}.` : '';
                    const contextPrompt = context.length ? `Previous conversation context: ${JSON.stringify(context)}. ` : '';
                    const memoryPrompt = Object.keys(memory).length ? `Relevant memory: ${JSON.stringify(memory)}. ` : '';
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 4000);
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model === 'default' ? 'gpt-3.5-turbo' : model,
                            messages: [
                                { role: 'system', content: `${taskPrompt}${contextPrompt}${memoryPrompt}You are VerbiFlow, an advanced AI companion for creativity, coding, analytics, and more. Provide concise, insightful, and context-aware responses.${langPrompt}` },
                                { role: 'user', content: userMessage }
                            ],
                            max_tokens: 80,
                            temperature: 0.5,
                            top_p: 0.9,
                            presence_penalty: 0.1,
                            frequency_penalty: 0.1,
                            stream: true
                        }),
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error?.message || 'Failed to fetch AI response');
                    }
                    const reader = response.body.getReader();
                    let result = '';
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        const chunk = new TextDecoder().decode(value);
                        const lines = chunk.split('\n');
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                const data = line.slice(6);
                                if (data === '[DONE]') break;
                                try {
                                    const parsed = JSON.parse(data);
                                    const content = parsed.choices[0].delta.content || '';
                                    result += content;
                                } catch (e) {}
                            }
                        }
                    }
                    return result.trim();
                } catch (error) {
                    return `Error: ${error.message}. Please check your API key or network connection.`;
                }
            },
            async saveUserData(data) {
                await new Promise(resolve => setTimeout(resolve, 80));
                return { success: true, message: 'User data saved!' };
            },
            async analyzeFile(file) {
                await new Promise(resolve => setTimeout(resolve, 150));
                return `Analysis of ${file.name}: This is a ${file.type} file of size ${(file.size / 1024).toFixed(2)} KB. (Mock analysis)`;
            }
        };
        const initDB = () => new Promise((resolve, reject) => {
            const request = indexedDB.open('VerbiFlowDB', 1);
            request.onupgradeneeded = event => {
                const db = event.target.result;
                db.createObjectStore('state', { keyPath: 'id' });
            };
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject(event.target.error);
        });
        const saveToDB = (db, storeName, data) => new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put({ id: 'appState', ...data });
            request.onsuccess = () => resolve();
            request.onerror = event => reject(event.target.error);
        });
        const getFromDB = (db, storeName) => new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get('appState');
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject(event.target.error);
        });
        const debounce = (func, delay) => {
            let timeout;
            return (...args) => {
                clearTimeout(timeout);
                timeout = setTimeout(() => func(...args), delay);
            };
        };
        const showNotification = (message, type = 'success') => {
            store.dispatch({ type: 'ENQUEUE_NOTIFICATION', payload: { message, type } });
            processNotificationQueue();
        };
        const processNotificationQueue = () => {
            if (store.state.notificationQueue.length === 0) return;
            const { message, type } = store.state.notificationQueue[0];
            elements.notification.textContent = message;
            elements.notification.className = `notification ${type} show`;
            setTimeout(() => {
                elements.notification.className = 'notification';
                store.dispatch({ type: 'DEQUEUE_NOTIFICATION' });
                processNotificationQueue();
            }, 2000);
        };
        const sanitizeInput = input => {
            const div = document.createElement('div');
            div.textContent = input;
            return div.innerHTML;
        };
        const checkRateLimit = () => {
            const now = Date.now();
            if (now - store.state.lastAction < store.state.rateLimit.interval) {
                showNotification('Please wait before performing another action.', 'error');
                return false;
            }
            store.dispatch({ type: 'SET_STATE', payload: { lastAction: now } });
            return true;
        };
        const toggleTheme = () => {
            if (!checkRateLimit()) return;
            const isDarkMode = !store.state.isDarkMode;
            store.dispatch({ type: 'SET_STATE', payload: { isDarkMode } });
            document.body.classList.toggle('dark-mode');
            document.body.classList.remove('custom-theme');
            elements.themeBtn.innerHTML = `<i class="fas ${isDarkMode ? 'fa-sun' : 'fa-moon'}"></i> ${isDarkMode ? 'Light Mode' : 'Dark Mode'}`;
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
        };
        const applyCustomTheme = () => {
            document.body.classList.add('custom-theme');
            document.body.style.setProperty('--custom-primary', elements.primaryColor.value);
            document.body.style.setProperty('--custom-secondary', elements.secondaryColor.value);
            document.body.style.setProperty('--custom-text', elements.textColor.value);
            document.body.style.setProperty('--custom-bg', elements.bgColor.value);
            document.body.style.setProperty('--custom-ai-bg', elements.aiBgColor.value);
            document.body.style.setProperty('--custom-user-bg', elements.userBgColor.value);
            document.body.style.setProperty('--custom-gradient', elements.gradientColor.value);
            elements.themePreview.style.background = `linear-gradient(135deg, ${elements.bgColor.value}, ${elements.gradientColor.value})`;
            localStorage.setItem('customTheme', JSON.stringify({
                primary: elements.primaryColor.value,
                secondary: elements.secondaryColor.value,
                text: elements.textColor.value,
                bg: elements.bgColor.value,
                aiBg: elements.aiBgColor.value,
                userBg: elements.userBgColor.value,
                gradient: elements.gradientColor.value
            }));
        };
        const loadTheme = () => {
            const savedTheme = localStorage.getItem('theme');
            const customTheme = JSON.parse(localStorage.getItem('customTheme'));
            if (savedTheme === 'dark') {
                store.dispatch({ type: 'SET_STATE', payload: { isDarkMode: true } });
                document.body.classList.add('dark-mode');
                elements.themeBtn.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
            }
            if (customTheme) {
                elements.primaryColor.value = customTheme.primary;
                elements.secondaryColor.value = customTheme.secondary;
                elements.textColor.value = customTheme.text;
                elements.bgColor.value = customTheme.bg;
                elements.aiBgColor.value = customTheme.aiBg;
                elements.userBgColor.value = customTheme.userBg;
                elements.gradientColor.value = customTheme.gradient;
                applyCustomTheme();
            }
        };
        const formatRelativeTime = timestamp => {
            const now = Date.now();
            const diff = Math.floor((now - timestamp) / 1000);
            if (diff < 60) return `${diff}s ago`;
            if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
            if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
            if (diff < 604800) return `${Math.floor(diff / 86400)}d ago`;
            return new Date(timestamp).toLocaleDateString();
        };
        const updateTimestamps = () => {
            document.querySelectorAll('.chat-message-meta span').forEach(span => {
                const messageId = span.closest('.chat-message').dataset.messageId;
                const message = store.state.conversationHistory.find(msg => msg.id === parseInt(messageId)) || 
                    Object.values(store.state.threads).flat().find(msg => msg.id === parseInt(messageId));
                if (message && message.timestamp) {
                    span.textContent = formatRelativeTime(message.timestamp);
                }
            });
            requestAnimationFrame(updateTimestamps);
        };
        const typeMessage = (content, contentDiv, callback) => {
            let index = 0;
            contentDiv.textContent = '';
            contentDiv.classList.add('typing-animation');
            const type = () => {
                if (index < content.length) {
                    contentDiv.textContent += content[index];
                    index++;
                    setTimeout(type, store.state.typingSpeed);
                } else {
                    callback();
                }
            };
            setTimeout(type, store.state.typingSpeed);
        };
        const virtualRenderMessages = () => {
            const fragment = document.createDocumentFragment();
            const start = (store.state.currentPage - 1) * store.state.messagesPerPage;
            const end = start + store.state.messagesPerPage;
            const messagesToRender = store.state.conversationHistory.slice(start, end);
            messagesToRender.forEach(message => {
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${message.role}${message.threadId ? ' threaded-message' : ''}${store.state.pinnedMessages.has(message.id) ? ' pinned' : ''}`;
                messageDiv.dataset.messageId = message.id;
                if (message.threadId) messageDiv.dataset.threadId = message.threadId;
                const contentDiv = document.createElement('div');
                contentDiv.className = 'chat-message-content';
                messageDiv.appendChild(contentDiv);
                const metaDiv = document.createElement('div');
                metaDiv.className = 'chat-message-meta';
                metaDiv.innerHTML = `<span>${formatRelativeTime(message.timestamp)}</span>`;
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'chat-message-actions';
                const copyBtn = document.createElement('button');
                copyBtn.className = 'copy-message-btn';
                copyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
                const editBtn = document.createElement('button');
                editBtn.className = 'edit-message-btn';
                editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
                editBtn.style.display = message.role === 'user' ? 'inline-block' : 'none';
                const reactBtn = document.createElement('button');
                reactBtn.className = 'react-message-btn';
                reactBtn.innerHTML = '<i class="fas fa-heart"></i> React';
                const pinBtn = document.createElement('button');
                pinBtn.className = 'pin-message-btn';
                pinBtn.innerHTML = store.state.pinnedMessages.has(message.id) ? '<i class="fas fa-thumbtack"></i> Unpin' : '<i class="fas fa-thumbtack"></i> Pin';
                const threadBtn = document.createElement('button');
                threadBtn.className = 'thread-message-btn';
                threadBtn.innerHTML = '<i class="fas fa-comment"></i> Thread';
                const shareBtn = document.createElement('button');
                shareBtn.className = 'share-message-btn';
                shareBtn.innerHTML = '<i class="fas fa-share"></i> Share';
                if (message.reactions.length) {
                    const reactionsSpan = document.createElement('span');
                    reactionsSpan.className = 'reaction-emoji';
                    reactionsSpan.textContent = message.reactions.join(' ');
                    actionsDiv.appendChild(reactionsSpan);
                }
                actionsDiv.appendChild(copyBtn);
                actionsDiv.appendChild(editBtn);
                actionsDiv.appendChild(reactBtn);
                actionsDiv.appendChild(pinBtn);
                actionsDiv.appendChild(threadBtn);
                actionsDiv.appendChild(shareBtn);
                metaDiv.appendChild(actionsDiv);
                messageDiv.appendChild(metaDiv);
                fragment.appendChild(messageDiv);
                if (store.state.threads[message.id]) {
                    store.state.threads[message.id].forEach(threadMessage => {
                        const threadDiv = document.createElement('div');
                        threadDiv.className = `chat-message ${threadMessage.role} threaded-message${store.state.pinnedMessages.has(threadMessage.id) ? ' pinned' : ''}`;
                        threadDiv.dataset.messageId = threadMessage.id;
                        threadDiv.dataset.threadId = message.id;
                        const threadContentDiv = document.createElement('div');
                        threadContentDiv.className = 'chat-message-content';
                        threadContentDiv.textContent = threadMessage.content;
                        threadDiv.appendChild(threadContentDiv);
                        const threadMetaDiv = document.createElement('div');
                        threadMetaDiv.className = 'chat-message-meta';
                        threadMetaDiv.innerHTML = `<span>${formatRelativeTime(threadMessage.timestamp)}</span>`;
                        const threadActionsDiv = document.createElement('div');
                        threadActionsDiv.className = 'chat-message-actions';
                        const threadCopyBtn = document.createElement('button');
                        threadCopyBtn.className = 'copy-message-btn';
                        threadCopyBtn.innerHTML = '<i class="fas fa-copy"></i> Copy';
                        const threadEditBtn = document.createElement('button');
                        threadEditBtn.className = 'edit-message-btn';
                        threadEditBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
                        threadEditBtn.style.display = threadMessage.role === 'user' ? 'inline-block' : 'none';
                        const threadReactBtn = document.createElement('button');
                        threadReactBtn.className = 'react-message-btn';
                        threadReactBtn.innerHTML = '<i class="fas fa-heart"></i> React';
                        const threadPinBtn = document.createElement('button');
                        threadPinBtn.className = 'pin-message-btn';
                        threadPinBtn.innerHTML = store.state.pinnedMessages.has(threadMessage.id) ? '<i class="fas fa-thumbtack"></i> Unpin' : '<i class="fas fa-thumbtack"></i> Pin';
                        const threadThreadBtn = document.createElement('button');
                        threadThreadBtn.className = 'thread-message-btn';
                        threadThreadBtn.innerHTML = '<i class="fas fa-comment"></i> Thread';
                        const threadShareBtn = document.createElement('button');
                        threadShareBtn.className = 'share-message-btn';
                        threadShareBtn.innerHTML = '<i class="fas fa-share"></i> Share';
                        if (threadMessage.reactions.length) {
                            const threadReactionsSpan = document.createElement('span');
                            threadReactionsSpan.className = 'reaction-emoji';
                            threadReactionsSpan.textContent = threadMessage.reactions.join(' ');
                            threadActionsDiv.appendChild(threadReactionsSpan);
                        }
                        threadActionsDiv.appendChild(threadCopyBtn);
                        threadActionsDiv.appendChild(threadEditBtn);
                        threadActionsDiv.appendChild(threadReactBtn);
                        threadActionsDiv.appendChild(threadPinBtn);
                        threadActionsDiv.appendChild(threadThreadBtn);
                        threadActionsDiv.appendChild(threadShareBtn);
                        threadMetaDiv.appendChild(threadActionsDiv);
                        threadDiv.appendChild(threadMetaDiv);
                        fragment.appendChild(threadDiv);
                    });
                }
                if (message.role === 'ai') {
                    typeMessage(message.content, contentDiv, () => {
                        messageDiv.classList.add('visible');
                        if (store.state.userProfile.preferences.autoScroll) {
                            elements.chatArea.scrollTo({ top: elements.chatArea.scrollHeight, behavior: 'smooth' });
                        }
                    });
                } else {
                    contentDiv.textContent = message.content;
                    setTimeout(() => messageDiv.classList.add('visible'), 5);
                    if (store.state.userProfile.preferences.autoScroll) {
                        elements.chatArea.scrollTo({ top: elements.chatArea.scrollHeight, behavior: 'smooth' });
                    }
                }
            });
            elements.chatHistory.innerHTML = '';
            elements.chatHistory.appendChild(fragment);
            elements.messageCounter.textContent = `Messages: ${store.state.messageCount} | Sent: ${store.state.userStats.messagesSent} | Reactions: ${store.state.userStats.reactionsAdded} | Threads: ${store.state.userStats.threadsCreated}`;
        };
        const handleSendMessage = async (threadId = null) => {
            if (!checkRateLimit()) return;
            const userMessage = sanitizeInput(elements.userInput.value.trim());
            if (!userMessage || userMessage.length > 1000) {
                showNotification(userMessage ? 'Input too long! Maximum 1000 characters.' : 'Please enter a message.', 'error');
                return;
            }
            const messageId = Date.now();
            const newMessage = { id: messageId, role: 'user', content: userMessage, reactions: [], threadId, timestamp: Date.now() };
            if (threadId) {
                store.dispatch({ type: 'ADD_THREAD_MESSAGE', payload: newMessage });
            } else {
                store.dispatch({ type: 'ADD_MESSAGE', payload: newMessage });
            }
            elements.userInput.value = '';
            store.dispatch({ type: 'CLEAR_DRAFT', payload: 'userInput' });
            elements.typingIndicator.style.display = 'block';
            elements.responseSpinner.style.display = 'block';
            virtualRenderMessages();
            const keywords = userMessage.toLowerCase().split(/\W+/).filter(word => word.length > 3);
            const relevantMemory = {};
            keywords.forEach(keyword => {
                if (store.state.aiMemory[keyword]) relevantMemory[keyword] = store.state.aiMemory[keyword];
            });
            const aiResponse = await mockBackend.getAIResponse(
                userMessage,
                store.state.apiKey,
                store.state.selectedModel,
                store.state.selectedLanguage,
                store.state.selectedTask,
                store.state.conversationContext,
                relevantMemory
            );
            const aiMessage = { id: Date.now(), role: 'ai', content: aiResponse, reactions: [], threadId, timestamp: Date.now() };
            if (threadId) {
                store.dispatch({ type: 'ADD_THREAD_MESSAGE', payload: aiMessage });
            } else {
                store.dispatch({ type: 'ADD_MESSAGE', payload: aiMessage });
            }
            elements.typingIndicator.style.display = 'none';
            elements.responseSpinner.style.display = 'none';
            virtualRenderMessages();
        };
        const debouncedSendMessage = debounce(handleSendMessage, 40);
        const handleFileUpload = async event => {
            if (!checkRateLimit()) return;
            const files = Array.from(event.target.files);
            if (files.length > 5) {
                showNotification('Maximum 5 files allowed.', 'error');
                return;
            }
            const totalSize = files.reduce((sum, file) => sum + file.size, 0);
            if (totalSize > 10 * 1024 * 1024) {
                showNotification('Total file size exceeds 10MB limit.', 'error');
                return;
            }
            const newFiles = files.map(file => ({
                id: Date.now() + Math.random(),
                file,
                name: file.name,
                type: file.type,
                size: file.size,
                preview: null,
                analysis: null
            }));
            store.dispatch({ type: 'SET_FILES', payload: [...store.state.filesArray, ...newFiles] });
            elements.fileClearBtn.style.display = store.state.filesArray.length ? 'block' : 'none';
            renderFileList();
            newFiles.forEach(async fileObj => {
                if (fileObj.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = e => {
                        fileObj.preview = e.target.result;
                        renderFileList();
                    };
                    reader.readAsDataURL(fileObj.file);
                }
                const analysis = await mockBackend.analyzeFile(fileObj.file);
                fileObj.analysis = analysis;
                renderFileList();
            });
        };
        const renderFileList = () => {
            elements.fileList.innerHTML = '';
            store.state.filesArray.forEach(fileObj => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.dataset.fileId = fileObj.id;
                const fileIcon = document.createElement('i');
                fileIcon.className = `fas ${fileObj.type.startsWith('image/') ? 'fa-image' : fileObj.type.startsWith('video/') ? 'fa-video' : 'fa-file'}`;
                const fileName = document.createElement('span');
                fileName.className = 'file-item-name';
                fileName.textContent = fileObj.name;
                const fileDetails = document.createElement('span');
                fileDetails.className = 'file-item-details';
                fileDetails.textContent = `${(fileObj.size / 1024).toFixed(2)} KB${fileObj.analysis ? ` - ${fileObj.analysis}` : ''}`;
                fileItem.appendChild(fileIcon);
                fileItem.appendChild(fileName);
                fileItem.appendChild(fileDetails);
                elements.fileList.appendChild(fileItem);
            });
        };
        const clearFiles = () => {
            store.dispatch({ type: 'SET_FILES', payload: [] });
            elements.fileList.innerHTML = '';
            elements.fileClearBtn.style.display = 'none';
        };
        const previewFile = fileObj => {
            elements.filePreviewContent.innerHTML = '';
            if (fileObj.type.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = fileObj.preview;
                img.style.transform = `scale(${store.state.zoomLevel})`;
                elements.filePreviewContent.appendChild(img);
                elements.zoomControls.style.display = 'flex';
            } else if (fileObj.type.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = URL.createObjectURL(fileObj.file);
                video.controls = true;
                elements.filePreviewContent.appendChild(video);
                elements.zoomControls.style.display = 'none';
            } else {
                const text = document.createElement('div');
                text.textContent = fileObj.analysis || 'No preview available.';
                elements.filePreviewContent.appendChild(text);
                elements.zoomControls.style.display = 'none';
            }
            elements.filePreviewModal.classList.add('open');
        };
        const zoomIn = () => {
            store.state.zoomLevel = Math.min(store.state.zoomLevel + 0.1, 3);
            const img = elements.filePreviewContent.querySelector('img');
            if (img) img.style.transform = `scale(${store.state.zoomLevel})`;
        };
        const zoomOut = () => {
            store.state.zoomLevel = Math.max(store.state.zoomLevel - 0.1, 0.5);
            const img = elements.filePreviewContent.querySelector('img');
            if (img) img.style.transform = `scale(${store.state.zoomLevel})`;
        };
        const toggleSidebar = () => {
            if (!checkRateLimit()) return;
            elements.sidebar.classList.toggle('open');
            elements.menuBtn.innerHTML = elements.sidebar.classList.contains('open') ? '<i class="fas fa-times"></i> Close' : '<i class="fas fa-bars"></i> Menu';
        };
        const toggleFileActions = () => {
            if (!checkRateLimit()) return;
            elements.fileActionsContainer.classList.toggle('collapsed');
            elements.toggleActionsBtn.classList.toggle('collapsed');
        };
        const scrollToTop = () => {
            if (!checkRateLimit()) return;
            elements.chatArea.scrollTo({ top: 0, behavior: 'smooth' });
        };
        const handleScroll = () => {
            const isScrolled = elements.chatArea.scrollTop > 300;
            elements.backToTopBtn.classList.toggle('visible', isScrolled);
        };
        const saveUserProfile = () => {
            const userProfile = {
                username: sanitizeInput(elements.usernameInput.value) || 'User',
                chatLayout: elements.chatLayoutSelect.value,
                preferences: {
                    ...store.state.userProfile.preferences,
                    fontSize: parseInt(elements.fontSizeInput.value) || 16,
                    autoScroll: elements.autoScrollToggle.checked
                }
            };
            store.dispatch({ type: 'SET_STATE', payload: { userProfile } });
            applyChatLayout();
            showNotification('Profile updated!');
        };
        const applyChatLayout = () => {
            const layout = store.state.userProfile.chatLayout;
            const fontSize = store.state.userProfile.preferences.fontSize;
            document.querySelectorAll('.chat-message-content').forEach(content => {
                if (layout === 'compact') {
                    content.style.padding = '8px 12px';
                    content.style.fontSize = `${fontSize - 2}px`;
                    content.style.lineHeight = '1.4';
                } else if (layout === 'spacious') {
                    content.style.padding = '16px 20px';
                    content.style.fontSize = `${fontSize + 2}px`;
                    content.style.lineHeight = '1.8';
                } else {
                    content.style.padding = '12px 16px';
                    content.style.fontSize = `${fontSize}px`;
                    content.style.lineHeight = '1.5';
                }
            });
        };
        const exportChat = () => {
            if (!checkRateLimit()) return;
            const chatData = store.state.conversationHistory.map(msg => ({
                role: msg.role,
                content: msg.content,
                timestamp: new Date(msg.timestamp).toISOString(),
                reactions: msg.reactions,
                threadId: msg.threadId
            }));
            const blob = new Blob([JSON.stringify(chatData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `VerbiFlow_Chat_${new Date().toISOString()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showNotification('Chat exported successfully!');
        };
        const searchMessages = () => {
            const query = elements.searchModalInput.value.trim();
            if (!query) {
                elements.searchResults.innerHTML = '<p>Enter a search query.</p>';
                return;
            }
            store.dispatch({ type: 'ADD_SEARCH', payload: query });
            let results;
            try {
                const regex = new RegExp(query, 'i');
                results = store.state.conversationHistory.filter(msg => regex.test(msg.content));
            } catch (e) {
                results = store.state.conversationHistory.filter(msg => msg.content.toLowerCase().includes(query.toLowerCase()));
            }
            elements.searchResults.innerHTML = '';
            if (results.length === 0) {
                elements.searchResults.innerHTML = '<p>No results found.</p>';
                return;
            }
            results.forEach(msg => {
                const resultItem = document.createElement('div');
                resultItem.className = 'search-result-item';
                resultItem.dataset.messageId = msg.id;
                const highlightedContent = msg.content.replace(
                    new RegExp(query, 'gi'),
                    match => `<span class="highlight">${match}</span>`
                );
                resultItem.innerHTML = `<strong>${msg.role.toUpperCase()}</strong>: ${highlightedContent} <br><small>${formatRelativeTime(msg.timestamp)}</small>`;
                elements.searchResults.appendChild(resultItem);
            });
        };
        const handleUpdatesClick = () => {
            if (!checkRateLimit()) return;
            window.open('https://verbiflow.site/updates', '_blank');
            showNotification('Check out the latest updates!');
        };
        const handlePremiumPriceClick = () => {
            if (!checkRateLimit()) return;
            window.open('https://verbiflow.site/premium', '_blank');
            showNotification('Explore our premium plans!');
        };
        const loadConversationHistory = () => {
            virtualRenderMessages();
            if (store.state.filesArray.length) {
                renderFileList();
                elements.fileClearBtn.style.display =             'block';
            }
            elements.chatArea.scrollTo({ top: elements.chatArea.scrollHeight, behavior: 'smooth' });
        };

        const detectDevice = () => {
            const ua = navigator.userAgent;
            const isMobile = /Mobile|Android|iPhone|iPad/i.test(ua);
            const isChromebook = /CrOS/i.test(ua);
            const isTablet = /iPad|Android(?!.*Mobile)/i.test(ua);
            const osMatch = ua.match(/(Windows|Macintosh|Linux|Android|iOS)/i);
            const browserMatch = ua.match(/(Chrome|Safari|Firefox|Edge)/i);
            store.dispatch({ type: 'SET_STATE', payload: { 
                deviceType: isMobile ? 'mobile' : isChromebook ? 'chromebook' : isTablet ? 'tablet' : 'desktop',
                deviceInfo: {
                    os: osMatch ? osMatch[0] : 'Unknown',
                    browser: browserMatch ? browserMatch[0] : 'Unknown'
                }
            } });
            document.body.classList.add(isMobile ? 'mobile' : isChromebook ? 'chromebook' : isTablet ? 'tablet' : 'desktop');
            return { isMobile, isChromebook, isTablet };
        };

        const showLoadingMessages = async () => {
            const messages = [
                `Detecting device... ${store.state.deviceInfo.os} on ${store.state.deviceInfo.browser}`,
                'Optimizing UI for your device...',
                'Loading AI models...',
                'Ready to assist!'
            ];
            for (let i = 0; i < messages.length; i++) {
                elements.loadingText.textContent = messages[i];
                elements.loadingText.classList.add('visible');
                await new Promise(resolve => setTimeout(resolve, 600));
                elements.loadingText.classList.remove('visible');
                await new Promise(resolve => setTimeout(resolve, 150));
            }
        };

        const handleApiKeySubmission = async () => {
            const apiKey = elements.apiKeyInput.value.trim();
            if (!apiKey) {
                showNotification('Please enter an API key.', 'error');
                return;
            }
            elements.apiKeySubmit.disabled = true;
            elements.apiKeyInput.disabled = true;
            const validation = await mockBackend.validateApiKey(apiKey);
            if (validation.success) {
                store.dispatch({ type: 'SET_STATE', payload: { apiKey, isApiKeyValid: true } });
                showNotification(validation.message);
                elements.preloader.classList.add('hidden');
                setTimeout(() => {
                    elements.preloader.style.display = 'none';
                    loadConversationHistory();
                }, 250);
            } else {
                showNotification(validation.message, 'error');
                elements.apiKeySubmit.disabled = false;
                elements.apiKeyInput.disabled = false;
            }
        };

        elements.userInput.addEventListener('input', () => {
            elements.userInput.style.height = '40px';
            elements.userInput.style.height = `${elements.userInput.scrollHeight}px`;
            store.dispatch({ type: 'SET_DRAFT', payload: { userInput: elements.userInput.value } });
        });

        elements.userInput.addEventListener('keypress', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                debouncedSendMessage();
            }
        });

        elements.sendBtn.addEventListener('click', () => debouncedSendMessage());

        elements.fileInput.addEventListener('change', handleFileUpload);

        elements.fileClearBtn.addEventListener('click', clearFiles);

        elements.fileList.addEventListener('click', e => {
            const fileItem = e.target.closest('.file-item');
            if (!fileItem) return;
            const fileId = parseFloat(fileItem.dataset.fileId);
            const fileObj = store.state.filesArray.find(f => f.id === fileId);
            if (fileObj) previewFile(fileObj);
        });

        elements.filePreviewClose.addEventListener('click', () => elements.filePreviewModal.classList.remove('open'));

        elements.zoomIn.addEventListener('click', zoomIn);

        elements.zoomOut.addEventListener('click', zoomOut);

        elements.menuBtn.addEventListener('click', toggleSidebar);

        elements.sidebarClose.addEventListener('click', toggleSidebar);

        elements.clearChatBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            elements.confirmClearModal.classList.add('open');
        });

        elements.confirmClearModalClose.addEventListener('click', () => elements.confirmClearModal.classList.remove('open'));

        elements.confirmClearBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            store.dispatch({ type: 'SET_STATE', payload: { 
                conversationHistory: [], 
                messageCount: 0, 
                pinnedMessages: new Set(), 
                threads: {},
                userStats: { ...store.state.userStats, messagesSent: 0, reactionsAdded: 0, threadsCreated: 0 },
                conversationContext: [],
                aiMemory: {}
            } });
            const welcomeMessage = { id: Date.now(), role: 'ai', content: "Hey there, I’m VerbiFlow—your ultra-fast AI companion for creativity, coding, analytics, and more! What’s on your mind?", reactions: [], threadId: null, timestamp: Date.now() };
            store.dispatch({ type: 'ADD_MESSAGE', payload: welcomeMessage });
            store.dispatch({ type: 'SET_STATE', payload: { messageCount: 1 } });
            virtualRenderMessages();
            elements.confirmClearModal.classList.remove('open');
            showNotification('Conversation cleared!');
            toggleSidebar();
        });

        elements.cancelClearBtn.addEventListener('click', () => {
            elements.confirmClearModal.classList.remove('open');
        });

        elements.copyCodeBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            if (store.state.latestCodeBlocks.length) {
                navigator.clipboard.writeText(store.state.latestCodeBlocks.join('\n'));
                showNotification('Code copied to clipboard!');
            } else {
                showNotification('No code blocks to copy.', 'error');
            }
        });

        elements.discordBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            window.open(DISCORD_INVITE, '_blank');
            showNotification('Join our Discord community!');
        });

        elements.verbiflowUpdatesBtn.addEventListener('click', handleUpdatesClick);

        elements.premiumPriceBtn.addEventListener('click', handlePremiumPriceClick);

        elements.shareChatBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            const shareData = { title: 'VerbiFlow Chat', text: 'Check out my chat on VerbiFlow!', url: window.location.href };
            navigator.share(shareData).then(() => showNotification('Chat shared successfully!')).catch(() => showNotification('Sharing not supported on this device.', 'error'));
        });

        elements.shareWebsiteBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            const shareData = { title: 'VerbiFlow', text: 'Check out VerbiFlow - an ultra-fast AI companion!', url: WEBSITE_URL };
            navigator.share(shareData).then(() => showNotification('Website shared successfully!')).catch(() => showNotification('Sharing not supported on this device.', 'error'));
        });

        elements.themeBtn.addEventListener('click', toggleTheme);

        elements.userProfileBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            elements.usernameInput.value = store.state.userProfile.username;
            elements.chatLayoutSelect.value = store.state.userProfile.chatLayout;
            elements.fontSizeInput.value = store.state.userProfile.preferences.fontSize;
            elements.autoScrollToggle.checked = store.state.userProfile.preferences.autoScroll;
            elements.userProfileModal.classList.add('open');
        });

        elements.userProfileClose.addEventListener('click', () => elements.userProfileModal.classList.remove('open'));

        elements.usernameInput.addEventListener('change', saveUserProfile);

        elements.chatLayoutSelect.addEventListener('change', saveUserProfile);

        elements.fontSizeInput.addEventListener('change', saveUserProfile);

        elements.autoScrollToggle.addEventListener('change', saveUserProfile);

        elements.toggleActionsBtn.addEventListener('click', toggleFileActions);

        elements.generateMediaBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            showNotification('Media generation is a premium feature. Please upgrade!');
        });

        elements.voiceSearchBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            elements.permissionModal.classList.add('open');
        });

        elements.grantPermissionBtn.addEventListener('click', () => {
            elements.permissionModal.classList.remove('open');
            showNotification('Permissions granted! Voice search enabled.');
        });

        elements.denyPermissionBtn.addEventListener('click', () => {
            elements.permissionModal.classList.remove('open');
            showNotification('Permissions denied.', 'error');
        });

        elements.schoolHelpDropdown.addEventListener('change', () => {
            store.dispatch({ type: 'SET_STATE', payload: { selectedTask: elements.schoolHelpDropdown.value } });
        });

        elements.aiModelDropdown.addEventListener('change', () => {
            store.dispatch({ type: 'SET_STATE', payload: { selectedModel: elements.aiModelDropdown.value } });
        });

        elements.languageDropdown.addEventListener('change', () => {
            store.dispatch({ type: 'SET_STATE', payload: { selectedLanguage: elements.languageDropdown.value } });
        });

        elements.rephraseBtn.addEventListener('click', async () => {
            if (!checkRateLimit()) return;
            const lastUserMessage = store.state.conversationHistory.filter(msg => msg.role === 'user').slice(-1)[0];
            if (!lastUserMessage) {
                showNotification('No user message to rephrase.', 'error');
                return;
            }
            const keywords = lastUserMessage.content.toLowerCase().split(/\W+/).filter(word => word.length > 3);
            const relevantMemory = {};
            keywords.forEach(keyword => {
                if (store.state.aiMemory[keyword]) relevantMemory[keyword] = store.state.aiMemory[keyword];
            });
            const rephrased = await mockBackend.getAIResponse(
                `Rephrase: "${lastUserMessage.content}"`,
                store.state.apiKey,
                store.state.selectedModel,
                store.state.selectedLanguage,
                store.state.selectedTask,
                store.state.conversationContext,
                relevantMemory
            );
            const aiMessage = { id: Date.now(), role: 'ai', content: rephrased, reactions: [], threadId: null, timestamp: Date.now() };
            store.dispatch({ type: 'ADD_MESSAGE', payload: aiMessage });
            virtualRenderMessages();
        });

        elements.stopGeneratingBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            store.dispatch({ type: 'SET_STATE', payload: { isGenerating: false } });
            elements.stopGeneratingBtn.style.display = 'none';
            showNotification('Generation stopped.');
        });

        elements.feedbackBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            elements.feedbackModal.classList.add('open');
        });

        elements.feedbackSubmitBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            const feedback = elements.feedbackInput.value.trim();
            if (!feedback) {
                showNotification('Please enter feedback.', 'error');
                return;
            }
            const mailtoLink = `mailto:${FEEDBACK_EMAIL}?subject=VerbiFlow Feedback&body=${encodeURIComponent(feedback)}`;
            window.location.href = mailtoLink;
            elements.feedbackModal.classList.remove('open');
            elements.feedbackInput.value = '';
            showNotification('Thank you for your feedback!');
        });

        elements.feedbackModalClose.addEventListener('click', () => elements.feedbackModal.classList.remove('open'));

        elements.backToTopBtn.addEventListener('click', scrollToTop);

        elements.chatArea.addEventListener('scroll', handleScroll);

        elements.searchBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            elements.searchModal.classList.add('open');
        });

        elements.searchModalClose.addEventListener('click', () => elements.searchModal.classList.remove('open'));

        elements.searchModalInput.addEventListener('input', debounce(searchMessages, 150));

        elements.searchResults.addEventListener('click', e => {
            const resultItem = e.target.closest('.search-result-item');
            if (!resultItem) return;
            const messageId = parseInt(resultItem.dataset.messageId);
            const message = store.state.conversationHistory.find(msg => msg.id === messageId);
            if (!message) return;
            const messageDiv = elements.chatHistory.querySelector(`[data-message-id="${messageId}"]`);
            if (messageDiv) {
                messageDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
                messageDiv.style.background = 'rgba(255, 215, 0, 0.3)';
                setTimeout(() => (messageDiv.style.background = ''), 1000);
            }
            elements.searchModal.classList.remove('open');
        });

        elements.exportChatBtn.addEventListener('click', exportChat);

        elements.editMessageClose.addEventListener('click', () => elements.editMessageModal.classList.remove('open'));

        elements.saveEditBtn.addEventListener('click', () => {
            if (!checkRateLimit()) return;
            const messageId = parseInt(elements.editMessageModal.dataset.messageId);
            const threadId = elements.editMessageModal.dataset.threadId ? parseInt(elements.editMessageModal.dataset.threadId) : null;
            const updatedContent = sanitizeInput(elements.editMessageInput.value.trim());
            if (!updatedContent) {
                showNotification('Message cannot be empty.', 'error');
                return;
            }
            let message;
            if (threadId) {
                const threadMessages = store.state.threads[threadId] || [];
                message = threadMessages.find(msg => msg.id === messageId);
                if (message) {
                    message.content = updatedContent;
                    message.timestamp = Date.now();
                    store.dispatch({ type: 'UPDATE_MESSAGE', payload: message });
                }
            } else {
                message = store.state.conversationHistory.find(msg => msg.id === messageId);
                if (message) {
                    message.content = updatedContent;
                    message.timestamp = Date.now();
                    store.dispatch({ type: 'UPDATE_MESSAGE', payload: message });
                }
            }
            virtualRenderMessages();
            elements.editMessageModal.classList.remove('open');
            showNotification('Message updated!');
        });

        elements.chatHistory.addEventListener('click', async e => {
            const target = e.target.closest('button');
            if (!target) return;
            if (!checkRateLimit()) return;
            const messageDiv = target.closest('.chat-message');
            const messageId = parseInt(messageDiv.dataset.messageId);
            const threadId = messageDiv.dataset.threadId ? parseInt(messageDiv.dataset.threadId) : null;
            let message = store.state.conversationHistory.find(msg => msg.id === messageId);
            if (!message && threadId) {
                message = store.state.threads[threadId]?.find(msg => msg.id === messageId);
            }
            if (!message) return;
            if (target.classList.contains('copy-message-btn')) {
                navigator.clipboard.writeText(message.content);
                showNotification('Message copied!');
            } else if (target.classList.contains('edit-message-btn')) {
                elements.editMessageModal.dataset.messageId = messageId;
                if (threadId) elements.editMessageModal.dataset.threadId = threadId;
                elements.editMessageInput.value = message.content;
                elements.editMessageModal.classList.add('open');
            } else if (target.classList.contains('react-message-btn')) {
                message.reactions.push('❤️');
                store.dispatch({ type: 'ADD_REACTION' });
                store.dispatch({ type: 'UPDATE_MESSAGE', payload: message });
                virtualRenderMessages();
            } else if (target.classList.contains('pin-message-btn')) {
                if (store.state.pinnedMessages.has(messageId)) {
                    store.dispatch({ type: 'UNPIN_MESSAGE', payload: messageId });
                    showNotification('Message unpinned!');
                } else {
                    store.dispatch({ type: 'PIN_MESSAGE', payload: messageId });
                    showNotification('Message pinned!');
                }
                virtualRenderMessages();
            } else if (target.classList.contains('thread-message-btn')) {
                const userMessage = { id: Date.now(), role: 'user', content: 'Continue this thread...', reactions: [], threadId: messageId, timestamp: Date.now() };
                store.dispatch({ type: 'ADD_THREAD_MESSAGE', payload: userMessage });
                const keywords = userMessage.content.toLowerCase().split(/\W+/).filter(word => word.length > 3);
                const relevantMemory = {};
                keywords.forEach(keyword => {
                    if (store.state.aiMemory[keyword]) relevantMemory[keyword] = store.state.aiMemory[keyword];
                });
                const aiResponse = await mockBackend.getAIResponse(
                    userMessage.content,
                    store.state.apiKey,
                    store.state.selectedModel,
                    store.state.selectedLanguage,
                    store.state.selectedTask,
                    store.state.conversationContext,
                    relevantMemory
                );
                const aiMessage = { id: Date.now(), role: 'ai', content: aiResponse, reactions: [], threadId: messageId, timestamp: Date.now() };
                store.dispatch({ type: 'ADD_THREAD_MESSAGE', payload: aiMessage });
                virtualRenderMessages();
            } else if (target.classList.contains('share-message-btn')) {
                const shareData = { title: 'VerbiFlow Message', text: message.content, url: window.location.href };
                navigator.share(shareData).then(() => showNotification('Message shared successfully!')).catch(() => showNotification('Sharing not supported on this device.', 'error'));
            }
        });

        elements.primaryColor.addEventListener('input', applyCustomTheme);
        elements.secondaryColor.addEventListener('input', applyCustomTheme);
        elements.textColor.addEventListener('input', applyCustomTheme);
        elements.bgColor.addEventListener('input', applyCustomTheme);
        elements.aiBgColor.addEventListener('input', applyCustomTheme);
        elements.userBgColor.addEventListener('input', applyCustomTheme);
        elements.gradientColor.addEventListener('input', applyCustomTheme);

        elements.apiKeySubmit.addEventListener('click', handleApiKeySubmission);

        elements.apiKeyInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') handleApiKeySubmission();
        });

        const init = async () => {
            detectDevice();
            await showLoadingMessages();
            elements.apiKeyContainer.classList.add('visible');
            await store.loadState();
            loadTheme();
            applyChatLayout();
            if (store.state.messageDrafts.userInput) {
                elements.userInput.value = store.state.messageDrafts.userInput;
                elements.userInput.style.height = `${elements.userInput.scrollHeight}px`;
            }
            requestAnimationFrame(updateTimestamps);
        };

        init();
    </script>
</body>
</html>
